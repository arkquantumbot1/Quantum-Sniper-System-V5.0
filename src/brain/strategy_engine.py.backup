# src/brain/strategy_engine.py
"""é‡å­å¥‡ç‚¹ç‹™å‡»ç³»ç»Ÿ - ç­–ç•¥å¼•æ“Ž V5.0 (å®Œå…¨é‡æ–°å¼€å‘ + æžè‡´ä¼˜åŒ– + å®Œæ•´æ•´åˆç‰ˆæœ¬)"""

import logging
import asyncio
from typing import Dict, Any, Optional, List, Tuple, Callable
from datetime import datetime, timedelta
from enum import Enum
import uuid
from dataclasses import dataclass, field
from collections import deque, defaultdict
import threading
import time
from concurrent.futures import ThreadPoolExecutor, Future

# å¯¼å…¥æžè‡´ä¼˜åŒ–çš„ä¾èµ–æ¨¡å—
from interfaces import (
    IStrategySignal, SignalDirection, SignalPriority, PerformanceMetrics,
    InterfaceMetadata, SignalMetadata, MarketRegime, DataQualityLevel,
    IEventDispatcher, Event, EventPriority, IRiskManager, IMarketAnalyzer,
    ConfigScope, ConfigChange
)
from core.strategy_base import BaseStrategy, StrategySignal, StrategyFactory, StrategyError
from core.config_manager import BaseConfigManager, ConfigManagerFactory
from config.config import UnifiedConfigLoader, get_global_config

# æ¡ä»¶å¯¼å…¥ï¼Œç¡®ä¿å‘åŽå…¼å®¹
try:
    from brain.strategy_integration import (
        StrategyIntegrationEngine, StrategyIntegrationFactory,
        IntegrationMode, FusionResult, StrategyPerformance
    )
    HAS_INTEGRATION_ENGINE = True
except ImportError:
    HAS_INTEGRATION_ENGINE = False
    # åˆ›å»ºç®€åŒ–ç‰ˆæœ¬
    class StrategyPerformance:
        def __init__(self, strategy_name: str):
            self.strategy_name = strategy_name
            self.performance_score = 0.5
            self.signal_count = 0
            self.success_rate = 0.5
            self.last_updated = datetime.now()

class EngineState(Enum):
    """å¼•æ“ŽçŠ¶æ€æžšä¸¾ - æ•´åˆç‰ˆæœ¬"""
    INITIALIZING = "initializing"
    READY = "ready"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPING = "stopping"
    ERROR = "error"
    MAINTENANCE = "maintenance"

class ExecutionMode(Enum):
    """æ‰§è¡Œæ¨¡å¼æžšä¸¾ - æ•´åˆç‰ˆæœ¬"""
    REALTIME = "realtime"
    BACKTEST = "backtest"
    PAPER_TRADING = "paper_trading"
    SIMULATION = "simulation"

@dataclass
class EngineMetrics:
    """å¼•æ“ŽæŒ‡æ ‡æ•°æ®ç±» - æ•´åˆç‰ˆæœ¬"""
    total_strategies: int = 0
    active_strategies: int = 0
    signals_generated: int = 0
    signals_executed: int = 0
    execution_success_rate: float = 0.0
    average_signal_latency: float = 0.0
    memory_usage_mb: float = 0.0
    cpu_usage_percent: float = 0.0
    uptime_seconds: float = 0.0
    last_health_check: datetime = field(default_factory=datetime.now)

@dataclass
class StrategyContext:
    """ç­–ç•¥ä¸Šä¸‹æ–‡æ•°æ®ç±» - æ•´åˆç‰ˆæœ¬"""
    strategy_name: str
    market_data: Dict[str, Any]
    portfolio_state: Dict[str, Any]
    risk_parameters: Dict[str, Any]
    execution_mode: ExecutionMode
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

class StrategyEngine(BaseStrategy):
    """ç­–ç•¥å¼•æ“Ž V5.0 - å®Œæ•´æ•´åˆç‰ˆæœ¬"""
    
    # æŽ¥å£å…ƒæ•°æ®
    _metadata = InterfaceMetadata(
        version="5.0-integrated",
        description="æ™ºèƒ½ç­–ç•¥å¼•æ“Ž - å®Œæ•´æ•´åˆç‰ˆæœ¬ï¼Œå…¼å…·ç¨³å®šæ€§å’Œå®Œæ•´åŠŸèƒ½",
        author="Quantum-Sniper-Team",
        created_date=datetime.now(),
        performance_targets={
            "strategy_initialization_time": 0.01,
            "signal_processing_time": 0.005,
            "event_handling_time": 0.001
        },
        dependencies=[
            "BaseStrategy", "IEventDispatcher", "IRiskManager", 
            "IMarketAnalyzer", "BaseConfigManager"
        ],
        compatibility=["5.0", "4.2", "4.1", "emergency-rebuild"]
    )
    
    def __init__(self, name: str = "QuantumStrategyEngine", config: Dict[str, Any] = None):
        # é…ç½®å¤„ç† - æ•´åˆç‰ˆæœ¬
        config = config or {}
        default_config = {
            "name": name,
            "execution_mode": ExecutionMode.REALTIME.value,
            "max_concurrent_strategies": 10,
            "signal_batch_size": 100,
            "health_check_interval": 30,
            "performance_monitoring": True,
            "auto_recovery": True,
            "enable_advanced_features": False,  # é»˜è®¤å…³é—­é«˜çº§åŠŸèƒ½ï¼Œç¡®ä¿ç¨³å®šæ€§
            "event_driven_architecture": False  # é»˜è®¤å…³é—­äº‹ä»¶é©±åŠ¨
        }
        
        # å®Œæ•´ç‰ˆæœ¬é…ç½®æ‰©å±•ï¼ˆæ¡ä»¶å¯ç”¨ï¼‰
        advanced_defaults = {
            "enabled": True,
            "risk_level": "medium",
            "strategy_timeout_seconds": 300,
            "memory_usage_threshold_mb": 1024,
            "cpu_usage_threshold_percent": 80,
            "signal_validation_strict": True,
            "adaptive_load_balancing": False,  # é»˜è®¤å…³é—­
            "quantum_coherence_integration": False
        }
        
        default_config.update(advanced_defaults)
        default_config.update(config)
        
        super().__init__(name, default_config)
        
        # ==================== æ ¸å¿ƒå¼•æ“Žå±žæ€§ - æ•´åˆç‰ˆæœ¬ ====================
        
        # å¼•æ“ŽçŠ¶æ€ç®¡ç†
        self._engine_state: EngineState = EngineState.INITIALIZING
        self._execution_mode: ExecutionMode = ExecutionMode(config.get("execution_mode", "realtime"))
        self._last_state_change: datetime = datetime.now()
        
        # ç­–ç•¥ç®¡ç† - ä½¿ç”¨åº”æ€¥ç‰ˆæœ¬çš„ç¨³å®šå®žçŽ°
        self._strategies: Dict[str, BaseStrategy] = {}
        self._strategy_contexts: Dict[str, StrategyContext] = {}
        self._strategy_performance: Dict[str, StrategyPerformance] = {}
        self._strategy_dependencies: Dict[str, List[str]] = {}
        
        # é«˜çº§åŠŸèƒ½ç»„ä»¶ï¼ˆæ¡ä»¶åˆå§‹åŒ–ï¼‰
        self._enable_advanced_features = config.get("enable_advanced_features", False)
        self._event_dispatcher: Optional[IEventDispatcher] = None
        self._event_handlers: Dict[str, List[Callable]] = {}
        self._integration_engine: Optional[Any] = None
        
        # æ€§èƒ½ç›‘æŽ§ - æ•´åˆç‰ˆæœ¬
        self._engine_metrics = EngineMetrics()
        self._performance_metrics = PerformanceMetrics(
            execution_time=0.0,
            memory_usage=0,
            cpu_usage=0.0,
            call_count=0,
            error_count=0,
            cache_hit_rate=0.0
        )
        
        # çº¿ç¨‹å®‰å…¨
        self._engine_lock = threading.RLock()
        self._strategy_lock = threading.RLock()
        self._event_lock = threading.RLock()
        
        # å¼‚æ­¥æ‰§è¡Œ
        self._thread_pool = ThreadPoolExecutor(max_workers=config.get("max_concurrent_strategies", 10))
        self._pending_tasks: Dict[str, Future] = {}
        
        # ç¼“å­˜ç³»ç»Ÿ
        self._signal_cache: Dict[str, IStrategySignal] = {}
        self._market_data_cache: Dict[str, Any] = {}
        self._performance_cache: Dict[str, Any] = {}
        
        # å¥åº·ç›‘æŽ§
        self._health_check_timer: Optional[threading.Timer] = None
        self._last_health_check: datetime = datetime.now()
        
        # é”™è¯¯æ¢å¤
        self._error_count: Dict[str, int] = defaultdict(int)
        self._recovery_attempts: Dict[str, int] = defaultdict(int)
        
        self.logger = logging.getLogger(f"engine.{name}")
        
        # è‡ªåŠ¨åˆå§‹åŒ–å…³é”®ç»„ä»¶
        self._initialize_critical_components()
    
    @classmethod
    def get_interface_metadata(cls) -> InterfaceMetadata:
        """èŽ·å–æŽ¥å£å…ƒæ•°æ® - æ•´åˆç‰ˆæœ¬"""
        return cls._metadata
    
    def initialize(self) -> bool:
        """åˆå§‹åŒ–ç­–ç•¥å¼•æ“Ž - æ•´åˆç‰ˆæœ¬"""
        start_time = datetime.now()
        
        try:
            with self._engine_lock:
                if self.initialized:
                    self.logger.warning("ç­–ç•¥å¼•æ“Žå·²ç»åˆå§‹åŒ–")
                    return True
                
                self.logger.info("å¼€å§‹åˆå§‹åŒ–é‡å­ç­–ç•¥å¼•æ“Žï¼ˆæ•´åˆç‰ˆæœ¬ï¼‰...")
                self._update_engine_state(EngineState.INITIALIZING)
                
                # ==================== åˆ†æ­¥åˆå§‹åŒ–æµç¨‹ ====================
                
                # 1. åˆå§‹åŒ–é…ç½®ç³»ç»Ÿï¼ˆåº”æ€¥ç‰ˆæœ¬å®žçŽ°ï¼‰
                if not self._initialize_config_system():
                    raise StrategyError("é…ç½®ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥", self.name)
                
                # 2. æ¡ä»¶åˆå§‹åŒ–äº‹ä»¶ç³»ç»Ÿ
                if self._enable_advanced_features:
                    if not self._initialize_event_system():
                        self.logger.warning("äº‹ä»¶ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥ï¼Œç»§ç»­å…¶ä»–ç»„ä»¶")
                else:
                    self.logger.info("äº‹ä»¶ç³»ç»Ÿå·²ç¦ç”¨ï¼ˆç¨³å®šæ€§ä¼˜å…ˆï¼‰")
                
                # 3. åŠ è½½å’Œåˆå§‹åŒ–ç­–ç•¥ï¼ˆä½¿ç”¨åº”æ€¥ç‰ˆæœ¬çš„ç¨³å®šå®žçŽ°ï¼‰
                if not self._load_and_initialize_strategies():
                    raise StrategyError("ç­–ç•¥åŠ è½½å’Œåˆå§‹åŒ–å¤±è´¥", self.name)
                
                # 4. æ¡ä»¶åˆå§‹åŒ–æ•´åˆå¼•æ“Ž
                if self._enable_advanced_features and HAS_INTEGRATION_ENGINE:
                    if not self._initialize_integration_engine():
                        self.logger.warning("æ•´åˆå¼•æ“Žåˆå§‹åŒ–å¤±è´¥ï¼Œä½¿ç”¨åŸºç¡€æ¨¡å¼")
                else:
                    self.logger.info("æ•´åˆå¼•æ“Žå·²ç¦ç”¨")
                
                # 5. å¯åŠ¨å¥åº·ç›‘æŽ§
                if not self._start_health_monitoring():
                    self.logger.warning("å¥åº·ç›‘æŽ§å¯åŠ¨å¤±è´¥")
                
                # 6. éªŒè¯å¼•æ“Žå®Œæ•´æ€§
                if not self._validate_engine_integrity():
                    raise StrategyError("å¼•æ“Žå®Œæ•´æ€§éªŒè¯å¤±è´¥", self.name)
                
                # æ›´æ–°çŠ¶æ€å’Œæ€§èƒ½æŒ‡æ ‡
                self.initialized = True
                self._update_engine_state(EngineState.READY)
                
                initialization_time = (datetime.now() - start_time).total_seconds()
                self._performance_metrics.execution_time += initialization_time
                self._performance_metrics.call_count += 1
                
                self.logger.info(
                    f"ç­–ç•¥å¼•æ“Žåˆå§‹åŒ–å®Œæˆ: {len(self._strategies)} ä¸ªç­–ç•¥, "
                    f"è€—æ—¶: {initialization_time:.3f}s, "
                    f"é«˜çº§åŠŸèƒ½: {'å¯ç”¨' if self._enable_advanced_features else 'ç¦ç”¨'}"
                )
                
                # æ¡ä»¶å‘å¸ƒå¼•æ“Žå°±ç»ªäº‹ä»¶
                if self._enable_advanced_features:
                    self._publish_engine_event("engine_ready", {
                        "strategies_count": len(self._strategies),
                        "initialization_time": initialization_time,
                        "execution_mode": self._execution_mode.value,
                        "advanced_features": self._enable_advanced_features
                    })
                
                return True
                
        except Exception as e:
            self.logger.error(f"ç­–ç•¥å¼•æ“Žåˆå§‹åŒ–å¤±è´¥: {e}")
            self._update_engine_state(EngineState.ERROR)
            self._performance_metrics.error_count += 1
            return False
    
    def get_signal(self, data: Any) -> Optional[IStrategySignal]:
        """èŽ·å–äº¤æ˜“ä¿¡å· - æ•´åˆç‰ˆæœ¬"""
        if not self.initialized:
            self.logger.error("ç­–ç•¥å¼•æ“Žæœªåˆå§‹åŒ–")
            return None
        
        # å…è®¸åœ¨ READY å’Œ RUNNING çŠ¶æ€ä¸‹ç”Ÿæˆä¿¡å·
        if self._engine_state not in [EngineState.RUNNING, EngineState.READY]:
            self.logger.warning(f"ç­–ç•¥å¼•æ“ŽçŠ¶æ€ä¸º {self._engine_state.value}ï¼Œæ— æ³•ç”Ÿæˆä¿¡å·")
            return None
        
        start_time = datetime.now()
        
        try:
            # éªŒè¯è¾“å…¥æ•°æ®ï¼ˆåº”æ€¥ç‰ˆæœ¬å®žçŽ°ï¼‰
            if not self._validate_input_data(data):
                self.logger.warning("è¾“å…¥æ•°æ®éªŒè¯å¤±è´¥")
                return None
            
            # å¤„ç†å¸‚åœºæ•°æ®ï¼ˆåº”æ€¥ç‰ˆæœ¬å®žçŽ°ï¼‰
            processed_data = self._preprocess_market_data(data)
            if not processed_data:
                return None
            
            # åˆ›å»ºç­–ç•¥ä¸Šä¸‹æ–‡
            strategy_context = self._create_strategy_context(processed_data)
            
            # æ‰§è¡Œç­–ç•¥ä¿¡å·ç”Ÿæˆï¼ˆåº”æ€¥ç‰ˆæœ¬ç¨³å®šå®žçŽ°ï¼‰
            signals = self._execute_strategies(strategy_context)
            if not signals:
                self.logger.debug("æ— æœ‰æ•ˆç­–ç•¥ä¿¡å·ç”Ÿæˆ")
                return None
            
            # ä¿¡å·æ•´åˆä¸Žèžåˆï¼ˆæ¡ä»¶ä½¿ç”¨é«˜çº§åŠŸèƒ½ï¼‰
            if self._enable_advanced_features and self._integration_engine and len(signals) > 1:
                integrated_signal = self._integration_engine.get_signal(signals)
            else:
                # ä½¿ç”¨åº”æ€¥ç‰ˆæœ¬çš„ç®€å•æ•´åˆ
                integrated_signal = self._integrate_signals_simple(signals)
            
            if not integrated_signal:
                return None
            
            # éªŒè¯å’Œä¼˜åŒ–æœ€ç»ˆä¿¡å·
            final_signal = self._validate_and_optimize_signal(integrated_signal, strategy_context)
            if not final_signal:
                return None
            
            # æ›´æ–°æ€§èƒ½å’ŒæŒ‡æ ‡
            processing_time = (datetime.now() - start_time).total_seconds()
            self._update_signal_metrics(processing_time, len(signals))
            
            # æ¡ä»¶å‘å¸ƒä¿¡å·ç”Ÿæˆäº‹ä»¶
            if self._enable_advanced_features:
                self._publish_signal_event(final_signal, len(signals), processing_time)
            
            self.logger.debug(
                f"ä¿¡å·ç”Ÿæˆå®Œæˆ: {len(signals)} ä¸ªç­–ç•¥ä¿¡å·, "
                f"æ•´åˆä¿¡å·å¼ºåº¦: {final_signal.get_confidence():.3f}, "
                f"è€—æ—¶: {processing_time:.3f}s"
            )
            
            return final_signal
            
        except Exception as e:
            self.logger.error(f"ä¿¡å·ç”Ÿæˆå¤±è´¥: {e}")
            self._performance_metrics.error_count += 1
            self._handle_signal_generation_error(e)
            return None
    
    def get_status(self) -> Dict[str, Any]:
        """èŽ·å–ç­–ç•¥å¼•æ“ŽçŠ¶æ€ - æ•´åˆç‰ˆæœ¬"""
        try:
            # å®‰å…¨åœ°èŽ·å–åŸºç¡€çŠ¶æ€
            base_status = {}
            try:
                base_status = super().get_status() or {}
            except Exception as e:
                self.logger.warning(f"èŽ·å–åŸºç¡€çŠ¶æ€å¤±è´¥: {e}")
                base_status = {}
            
            # ç¡®ä¿ base_status æ˜¯å­—å…¸
            if not isinstance(base_status, dict):
                base_status = {}
            
            engine_status = {
                "engine_state": self._engine_state.value,
                "execution_mode": self._execution_mode.value,
                "total_strategies": len(self._strategies),
                "active_strategies": self._get_active_strategies_count(),
                "initialized": self.initialized,
                "last_state_change": self._last_state_change.isoformat(),
                "performance_metrics": self._get_performance_metrics_dict(),
                "engine_metrics": self._get_engine_metrics_dict(),
                "advanced_features_enabled": self._enable_advanced_features,
                "integration_engine_active": self._integration_engine is not None,
                "event_system_active": self._event_dispatcher is not None,
                "health_status": self._get_health_status(),
                "version": "5.0-integrated",
                "name": self.name
            }
            
            # åˆå¹¶åŸºç¡€çŠ¶æ€å’Œå¼•æ“ŽçŠ¶æ€
            return {**base_status, **engine_status}
            
        except Exception as e:
            self.logger.error(f"èŽ·å–å¼•æ“ŽçŠ¶æ€å¤±è´¥: {e}")
            return {
                "engine_state": "error",
                "error": str(e),
                "initialized": False,
                "version": "5.0-integrated",
                "name": self.name if hasattr(self, 'name') else "unknown"
            }
    
    # ==================== æ ¸å¿ƒæ–¹æ³• - æ•´åˆç‰ˆæœ¬ ====================
    
    def enable_advanced_features(self) -> bool:
        """å¯ç”¨é«˜çº§åŠŸèƒ½ - åŠ¨æ€å¯ç”¨"""
        try:
            if self._enable_advanced_features:
                self.logger.info("é«˜çº§åŠŸèƒ½å·²ç»å¯ç”¨")
                return True
            
            self.logger.info("æ­£åœ¨å¯ç”¨é«˜çº§åŠŸèƒ½...")
            
            # å¯ç”¨äº‹ä»¶ç³»ç»Ÿ
            if not self._initialize_event_system():
                self.logger.warning("äº‹ä»¶ç³»ç»Ÿå¯ç”¨å¤±è´¥")
            
            # å¯ç”¨æ•´åˆå¼•æ“Ž
            if HAS_INTEGRATION_ENGINE and not self._initialize_integration_engine():
                self.logger.warning("æ•´åˆå¼•æ“Žå¯ç”¨å¤±è´¥")
            
            self._enable_advanced_features = True
            self.logger.info("é«˜çº§åŠŸèƒ½å¯ç”¨å®Œæˆ")
            return True
            
        except Exception as e:
            self.logger.error(f"å¯ç”¨é«˜çº§åŠŸèƒ½å¤±è´¥: {e}")
            return False
    
    def disable_advanced_features(self) -> bool:
        """ç¦ç”¨é«˜çº§åŠŸèƒ½ - å›žåˆ°ç¨³å®šæ¨¡å¼"""
        try:
            if not self._enable_advanced_features:
                self.logger.info("é«˜çº§åŠŸèƒ½å·²ç»ç¦ç”¨")
                return True
            
            self.logger.info("æ­£åœ¨ç¦ç”¨é«˜çº§åŠŸèƒ½...")
            
            # åœæ­¢äº‹ä»¶ç³»ç»Ÿ
            self._event_dispatcher = None
            self._event_handlers.clear()
            
            # åœæ­¢æ•´åˆå¼•æ“Ž
            self._integration_engine = None
            
            self._enable_advanced_features = False
            self.logger.info("é«˜çº§åŠŸèƒ½ç¦ç”¨å®Œæˆ")
            return True
            
        except Exception as e:
            self.logger.error(f"ç¦ç”¨é«˜çº§åŠŸèƒ½å¤±è´¥: {e}")
            return False
    
    # ==================== åº”æ€¥ç‰ˆæœ¬çš„æ ¸å¿ƒå®žçŽ° ====================
    
    def _load_and_initialize_strategies(self) -> bool:
        """åŠ è½½å’Œåˆå§‹åŒ–ç­–ç•¥ - åº”æ€¥ç‰ˆæœ¬ç¨³å®šå®žçŽ°"""
        try:
            # ä»Žé…ç½®åŠ è½½ç­–ç•¥åˆ—è¡¨
            strategy_configs = self.config.get("strategies", [])
            
            if not strategy_configs:
                self.logger.warning("æœªé…ç½®ç­–ç•¥åˆ—è¡¨ï¼Œä½¿ç”¨åº”æ€¥ç­–ç•¥å‘çŽ°")
                return self._emergency_strategy_discovery()
            
            loaded_count = 0
            for strategy_config in strategy_configs:
                strategy_name = strategy_config.get("name")
                strategy_type = strategy_config.get("type")
                
                if not strategy_name or not strategy_type:
                    self.logger.warning("è·³è¿‡æ— æ•ˆçš„ç­–ç•¥é…ç½®")
                    continue
                
                try:
                    # ä½¿ç”¨ç­–ç•¥å·¥åŽ‚åˆ›å»ºç­–ç•¥
                    strategy_instance = StrategyFactory.create_strategy(
                        strategy_name, strategy_config
                    )
                    
                    if strategy_instance and strategy_instance.initialize():
                        self._strategies[strategy_name] = strategy_instance
                        self._strategy_dependencies[strategy_name] = strategy_config.get("dependencies", [])
                        self._strategy_performance[strategy_name] = StrategyPerformance(
                            strategy_name=strategy_name
                        )
                        loaded_count += 1
                        self.logger.info(f"âœ… ç­–ç•¥åŠ è½½æˆåŠŸ: {strategy_name}")
                    else:
                        self.logger.error(f"âŒ ç­–ç•¥åˆå§‹åŒ–å¤±è´¥: {strategy_name}")
                        
                except Exception as e:
                    self.logger.error(f"âŒ ç­–ç•¥åŠ è½½å¼‚å¸¸ {strategy_name}: {e}")
            
            if loaded_count == 0:
                self.logger.error("âŒ æ— ç­–ç•¥æˆåŠŸåŠ è½½")
                return False
            
            self.logger.info(f"ðŸŽ¯ ç­–ç•¥åŠ è½½å®Œæˆ: {loaded_count} ä¸ªç­–ç•¥")
            return True
            
        except Exception as e:
            self.logger.error(f"ç­–ç•¥åŠ è½½è¿‡ç¨‹å¼‚å¸¸: {e}")
            return False
    
    def _emergency_strategy_discovery(self):
        """åº”æ€¥ç­–ç•¥å‘çŽ° - ç¨³å®šå¯é çš„å®žçŽ°"""
        try:
            self.logger.info("å¼€å§‹åº”æ€¥ç­–ç•¥å‘çŽ°è¿‡ç¨‹...")
            
            # åº”æ€¥åŸºç¡€ç­–ç•¥ - å®Œå…¨å®žçŽ°çš„ç¨³å®šç‰ˆæœ¬
            class EmergencyBaseStrategy(BaseStrategy):
                """åº”æ€¥åŸºç¡€ç­–ç•¥ - å®Œå…¨å®žçŽ°æ‰€æœ‰æŠ½è±¡æ–¹æ³•"""
                
                def __init__(self, name, config=None):
                    super().__init__(name, config or {})
                    self.initialized = False
                    self.signal_count = 0
                
                def initialize(self):
                    self.initialized = True
                    self.logger.info(f"åº”æ€¥ç­–ç•¥åˆå§‹åŒ–å®Œæˆ: {self.name}")
                    return True
                
                def get_signal(self, data):
                    if not self.initialized:
                        return None
                    
                    self.signal_count += 1
                    
                    from interfaces import SignalDirection, SignalMetadata
                    from core.strategy_base import StrategySignal
                    
                    metadata = SignalMetadata(
                        source="emergency_base_strategy",
                        tags=["emergency", "stable"]
                    )
                    
                    return StrategySignal(
                        signal_type="EMERGENCY_BASE",
                        confidence=0.5,
                        data={"strategy": "emergency_base", "signal_count": self.signal_count},
                        direction=SignalDirection.NEUTRAL,
                        metadata=metadata
                    )
                
                def get_status(self):
                    return {
                        "name": self.name,
                        "initialized": self.initialized,
                        "signal_count": self.signal_count,
                        "strategy_type": "emergency_base"
                    }
            
            # åˆ›å»ºåº”æ€¥ç­–ç•¥
            strategy_names = ["EmergencyTrend", "EmergencyMeanReversion", "EmergencyBreakout"]
            loaded_count = 0
            
            for strategy_name in strategy_names:
                try:
                    strategy_instance = EmergencyBaseStrategy(strategy_name, {})
                    
                    if strategy_instance and strategy_instance.initialize():
                        self._strategies[strategy_name] = strategy_instance
                        self._strategy_dependencies[strategy_name] = []
                        self._strategy_performance[strategy_name] = StrategyPerformance(
                            strategy_name=strategy_name
                        )
                        loaded_count += 1
                        self.logger.info(f"âœ… åº”æ€¥ç­–ç•¥åŠ è½½æˆåŠŸ: {strategy_name}")
                    else:
                        self.logger.error(f"âŒ åº”æ€¥ç­–ç•¥åˆå§‹åŒ–å¤±è´¥: {strategy_name}")
                        
                except Exception as e:
                    self.logger.error(f"âŒ åº”æ€¥ç­–ç•¥åŠ è½½å¼‚å¸¸ {strategy_name}: {e}")
            
            if loaded_count == 0:
                self.logger.error("âŒ æ— åº”æ€¥ç­–ç•¥æˆåŠŸåŠ è½½")
                return False
            
            self.logger.info(f"ðŸŽ¯ åº”æ€¥ç­–ç•¥åŠ è½½å®Œæˆ: {loaded_count} ä¸ªç­–ç•¥")
            return True
            
        except Exception as e:
            self.logger.error(f"ðŸ’¥ åº”æ€¥ç­–ç•¥å‘çŽ°è¿‡ç¨‹å¼‚å¸¸: {e}")
            return False
    
    def _integrate_signals_simple(self, signals: Dict[str, IStrategySignal]) -> Optional[IStrategySignal]:
        """ç®€å•ä¿¡å·æ•´åˆ - åº”æ€¥ç‰ˆæœ¬ç¨³å®šå®žçŽ°"""
        try:
            # ç®€å•æ•´åˆï¼šé€‰æ‹©ç½®ä¿¡åº¦æœ€é«˜çš„ä¿¡å·
            best_signal = None
            best_confidence = 0.0
            
            for signal in signals.values():
                confidence = signal.get_confidence()
                if confidence > best_confidence:
                    best_confidence = confidence
                    best_signal = signal
            
            return best_signal
            
        except Exception as e:
            self.logger.error(f"ç®€å•ä¿¡å·æ•´åˆå¤±è´¥: {e}")
            # è¿”å›žç¬¬ä¸€ä¸ªä¿¡å·ä½œä¸ºé™çº§æ–¹æ¡ˆ
            return next(iter(signals.values())) if signals else None
    
    # ==================== é«˜çº§åŠŸèƒ½çš„æ¡ä»¶å®žçŽ° ====================
    
    def _initialize_event_system(self) -> bool:
        """åˆå§‹åŒ–äº‹ä»¶ç³»ç»Ÿ - æ¡ä»¶å®žçŽ°"""
        if not self._enable_advanced_features:
            return True
            
        try:
            # è¿™é‡Œåº”è¯¥ä»ŽæŽ¥å£æ³¨å†Œè¡¨èŽ·å–äº‹ä»¶åˆ†å‘å™¨
            # ç®€åŒ–å®žçŽ°ï¼šåˆ›å»ºåŸºæœ¬çš„äº‹ä»¶å¤„ç†å™¨
            
            self._event_handlers = {
                "engine_state_change": [],
                "strategy_signal": [],
                "performance_alert": [],
                "error_occurred": []
            }
            
            self.logger.info("äº‹ä»¶ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ")
            return True
            
        except Exception as e:
            self.logger.error(f"äº‹ä»¶ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: {e}")
            return False
    
    def _initialize_integration_engine(self) -> bool:
        """åˆå§‹åŒ–æ•´åˆå¼•æ“Ž - æ¡ä»¶å®žçŽ°"""
        if not self._enable_advanced_features or not HAS_INTEGRATION_ENGINE:
            return True
            
        try:
            integration_config = self.config.get("integration", {})
            self._integration_engine = StrategyIntegrationFactory.create_integration_engine(
                f"{self.name}_integration", integration_config
            )
            
            # å°†æ‰€æœ‰ç­–ç•¥æ·»åŠ åˆ°æ•´åˆå¼•æ“Ž
            for strategy_name, strategy_instance in self._strategies.items():
                initial_weight = 1.0 / len(self._strategies)
                self._integration_engine.add_strategy(strategy_name, strategy_instance, initial_weight)
            
            self.logger.info("æ•´åˆå¼•æ“Žåˆå§‹åŒ–å®Œæˆ")
            return True
            
        except Exception as e:
            self.logger.error(f"æ•´åˆå¼•æ“Žåˆå§‹åŒ–å¤±è´¥: {e}")
            return False
    
    # ==================== å…±äº«å·¥å…·æ–¹æ³• ====================
    
    def _validate_input_data(self, data: Any) -> bool:
        """éªŒè¯è¾“å…¥æ•°æ® - å…±äº«å®žçŽ°"""
        if data is None:
            return False
        
        # åŸºæœ¬æ•°æ®éªŒè¯
        if isinstance(data, dict):
            required_fields = ["timestamp", "symbol", "price"]
            for field in required_fields:
                if field not in data:
                    self.logger.warning(f"è¾“å…¥æ•°æ®ç¼ºå°‘å¿…éœ€å­—æ®µ: {field}")
                    return False
        
        return True
    
    def _preprocess_market_data(self, data: Any) -> Dict[str, Any]:
        """é¢„å¤„ç†å¸‚åœºæ•°æ® - å…±äº«å®žçŽ°"""
        try:
            processed_data = {}
            
            if isinstance(data, dict):
                # åŸºæœ¬æ•°æ®è½¬æ¢
                processed_data = {
                    "market_data": data,
                    "timestamp": data.get("timestamp", datetime.now()),
                    "symbol": data.get("symbol", "UNKNOWN"),
                    "price": float(data.get("price", 0)),
                    "volume": float(data.get("volume", 0)),
                    "metadata": {
                        "processing_time": datetime.now(),
                        "data_quality": DataQualityLevel.GOOD.value
                    }
                }
            
            return processed_data
            
        except Exception as e:
            self.logger.error(f"å¸‚åœºæ•°æ®é¢„å¤„ç†å¤±è´¥: {e}")
            return {}
    
    def _execute_strategies(self, context: StrategyContext) -> Dict[str, IStrategySignal]:
        """æ‰§è¡Œç­–ç•¥ä¿¡å·ç”Ÿæˆ - å…±äº«å®žçŽ°"""
        signals = {}
        active_count = 0
        
        for strategy_name, strategy in self._strategies.items():
            try:
                # æ£€æŸ¥ç­–ç•¥ä¾èµ–æ˜¯å¦æ»¡è¶³
                if not self._check_strategy_dependencies(strategy_name):
                    self.logger.debug(f"ç­–ç•¥ä¾èµ–ä¸æ»¡è¶³: {strategy_name}")
                    continue
                
                # æ‰§è¡Œç­–ç•¥
                signal = strategy.get_signal(context.market_data)
                if signal and hasattr(signal, 'get_confidence'):
                    signals[strategy_name] = signal
                    active_count += 1
                    
                    # æ›´æ–°ç­–ç•¥æ€§èƒ½
                    self._update_strategy_performance(strategy_name, signal)
                else:
                    self.logger.debug(f"ç­–ç•¥æ— æœ‰æ•ˆä¿¡å·: {strategy_name}")
                    
            except Exception as e:
                self.logger.error(f"ç­–ç•¥æ‰§è¡Œå¤±è´¥ {strategy_name}: {e}")
                self._handle_strategy_error(strategy_name, e)
        
        self._engine_metrics.active_strategies = active_count
        return signals
    
    def _update_strategy_performance(self, strategy_name: str, signal: IStrategySignal):
        """æ›´æ–°ç­–ç•¥æ€§èƒ½ - å…±äº«å®žçŽ°"""
        if strategy_name not in self._strategy_performance:
            self._strategy_performance[strategy_name] = StrategyPerformance(
                strategy_name=strategy_name
            )
        
        performance = self._strategy_performance[strategy_name]
        performance.signal_count += 1
        
        # ç®€åŒ–çš„æˆåŠŸçŽ‡è®¡ç®—
        signal_confidence = signal.get_confidence()
        performance.success_rate = (
            performance.success_rate * 0.9 + signal_confidence * 0.1
        )
        
        performance.last_updated = datetime.now()
    
    # ==================== æ–°å¢žé«˜çº§æ–¹æ³• ====================
    
    async def get_signal_async(self, data: Any) -> Optional[IStrategySignal]:
        """å¼‚æ­¥èŽ·å–äº¤æ˜“ä¿¡å· - é«˜çº§åŠŸèƒ½"""
        if not self._enable_advanced_features:
            self.logger.warning("å¼‚æ­¥ä¿¡å·ç”Ÿæˆéœ€è¦å¯ç”¨é«˜çº§åŠŸèƒ½")
            return self.get_signal(data)
            
        try:
            return await asyncio.get_event_loop().run_in_executor(
                None, self.get_signal, data
            )
        except Exception as e:
            self.logger.error(f"å¼‚æ­¥ä¿¡å·ç”Ÿæˆå¤±è´¥: {e}")
            return None
    
    def start_engine(self) -> bool:
        """å¯åŠ¨ç­–ç•¥å¼•æ“Ž - æ•´åˆç‰ˆæœ¬"""
        try:
            with self._engine_lock:
                if self._engine_state == EngineState.RUNNING:
                    self.logger.warning("ç­–ç•¥å¼•æ“Žå·²ç»åœ¨è¿è¡Œä¸­")
                    return True
                
                if not self.initialized:
                    self.logger.error("ç­–ç•¥å¼•æ“Žæœªåˆå§‹åŒ–ï¼Œæ— æ³•å¯åŠ¨")
                    return False
                
                self._update_engine_state(EngineState.RUNNING)
                
                # å¯åŠ¨æ‰€æœ‰ç­–ç•¥
                success_count = 0
                for strategy_name, strategy in self._strategies.items():
                    try:
                        # å¦‚æžœç­–ç•¥æœ‰å¯åŠ¨æ–¹æ³•ï¼Œåˆ™è°ƒç”¨å®ƒ
                        if hasattr(strategy, 'start_strategy'):
                            strategy.start_strategy()
                        self.logger.info(f"å¯åŠ¨ç­–ç•¥: {strategy_name}")
                        success_count += 1
                    except Exception as e:
                        self.logger.error(f"ç­–ç•¥å¯åŠ¨å¤±è´¥ {strategy_name}: {e}")
                
                # æ¡ä»¶å¯åŠ¨æ•´åˆå¼•æ“Ž
                if self._integration_engine:
                    try:
                        self._integration_engine.optimize_strategy()
                        self.logger.info("æ•´åˆå¼•æ“Žä¼˜åŒ–å®Œæˆ")
                    except Exception as e:
                        self.logger.warning(f"æ•´åˆå¼•æ“Žä¼˜åŒ–å¤±è´¥: {e}")
                
                self.logger.info(f"ç­–ç•¥å¼•æ“Žå¯åŠ¨å®Œæˆ: {success_count}/{len(self._strategies)} ä¸ªç­–ç•¥")
                
                # æ¡ä»¶å‘å¸ƒå¼•æ“Žå¯åŠ¨äº‹ä»¶
                if self._enable_advanced_features:
                    self._publish_engine_event("engine_started", {
                        "active_strategies": success_count,
                        "total_strategies": len(self._strategies)
                    })
                
                return success_count > 0
                
        except Exception as e:
            self.logger.error(f"ç­–ç•¥å¼•æ“Žå¯åŠ¨å¤±è´¥: {e}")
            self._update_engine_state(EngineState.ERROR)
            return False
    
    def get_engine_insights(self) -> Dict[str, Any]:
        """èŽ·å–å¼•æ“Žæ´žå¯Ÿ - é«˜çº§åŠŸèƒ½"""
        if not self._enable_advanced_features:
            return {"error": "é«˜çº§åŠŸèƒ½æœªå¯ç”¨"}
            
        try:
            insights = {
                "engine_health": self._get_health_status(),
                "strategy_analysis": {},
                "performance_analysis": {},
                "resource_utilization": {},
                "recommendations": []
            }
            
            # ç­–ç•¥åˆ†æž
            for strategy_name, performance in self._strategy_performance.items():
                insights["strategy_analysis"][strategy_name] = {
                    "performance_score": performance.performance_score,
                    "signal_count": performance.signal_count,
                    "success_rate": performance.success_rate,
                    "last_updated": performance.last_updated.isoformat()
                }
            
            return insights
            
        except Exception as e:
            self.logger.error(f"èŽ·å–å¼•æ“Žæ´žå¯Ÿå¤±è´¥: {e}")
            return {"error": str(e)}
    
    # ==================== äº‹ä»¶å‘å¸ƒæ–¹æ³• ====================
    
    def _publish_engine_event(self, event_type: str, data: Dict[str, Any]):
        """å‘å¸ƒå¼•æ“Žäº‹ä»¶ - æ¡ä»¶å®žçŽ°"""
        if not self._enable_advanced_features:
            return
            
        try:
            if self._event_dispatcher:
                event = Event(
                    event_type=event_type,
                    data=data,
                    source=self.name,
                    priority=EventPriority.NORMAL
                )
                self._event_dispatcher.dispatch_event_async(event)
            else:
                # ç®€åŒ–äº‹ä»¶å¤„ç†
                if event_type in self._event_handlers:
                    for handler in self._event_handlers[event_type]:
                        try:
                            handler(event_type, data)
                        except Exception as e:
                            self.logger.error(f"äº‹ä»¶å¤„ç†å™¨æ‰§è¡Œå¤±è´¥: {e}")
                            
        except Exception as e:
            self.logger.debug(f"äº‹ä»¶å‘å¸ƒå¤±è´¥: {e}")
    
    def _publish_signal_event(self, signal: IStrategySignal, strategy_count: int, 
                             processing_time: float):
        """å‘å¸ƒä¿¡å·äº‹ä»¶ - æ¡ä»¶å®žçŽ°"""
        if not self._enable_advanced_features:
            return
            
        event_data = {
            "signal_confidence": signal.get_confidence(),
            "signal_direction": signal.get_signal_direction().value,
            "strategy_count": strategy_count,
            "processing_time": processing_time,
            "timestamp": datetime.now().isoformat()
        }
        self._publish_engine_event("strategy_signal", event_data)

    # ==================== æ–°å¢žç¼ºå¤±çš„æ–¹æ³•å®žçŽ° ====================

    def _initialize_critical_components(self):
        """åˆå§‹åŒ–å…³é”®ç»„ä»¶ - æ•´åˆç‰ˆæœ¬"""
        try:
            self.logger.debug("å¼€å§‹åˆå§‹åŒ–å…³é”®ç»„ä»¶...")
            
            # åˆå§‹åŒ–åŸºç¡€é…ç½®
            self._initialize_base_config()
            
            # åˆå§‹åŒ–æ€§èƒ½ç›‘æŽ§
            self._initialize_performance_monitoring()
            
            # åˆå§‹åŒ–ç¼“å­˜ç³»ç»Ÿ
            self._initialize_cache_systems()
            
            self.logger.debug("å…³é”®ç»„ä»¶åˆå§‹åŒ–å®Œæˆ")
            
        except Exception as e:
            self.logger.error(f"å…³é”®ç»„ä»¶åˆå§‹åŒ–å¤±è´¥: {e}")
            # ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œå…è®¸ç»§ç»­åˆå§‹åŒ–å…¶ä»–ç»„ä»¶

    def _initialize_base_config(self):
        """åˆå§‹åŒ–åŸºç¡€é…ç½®"""
        # è®¾ç½®é»˜è®¤é…ç½®å€¼
        if not hasattr(self, '_engine_metrics'):
            self._engine_metrics = EngineMetrics()
        
        if not hasattr(self, '_performance_metrics'):
            self._performance_metrics = PerformanceMetrics(
                execution_time=0.0,
                memory_usage=0,
                cpu_usage=0.0,
                call_count=0,
                error_count=0,
                cache_hit_rate=0.0
            )

    def _initialize_performance_monitoring(self):
        """åˆå§‹åŒ–æ€§èƒ½ç›‘æŽ§"""
        # åˆå§‹åŒ–æ€§èƒ½è®¡æ•°å™¨
        self._performance_counters = {
            'signals_generated': 0,
            'strategies_executed': 0,
            'errors_encountered': 0
        }

    def _initialize_cache_systems(self):
        """åˆå§‹åŒ–ç¼“å­˜ç³»ç»Ÿ"""
        # ç¡®ä¿ç¼“å­˜å­—å…¸å·²åˆå§‹åŒ–
        if not hasattr(self, '_signal_cache'):
            self._signal_cache = {}
        if not hasattr(self, '_market_data_cache'):
            self._market_data_cache = {}
        if not hasattr(self, '_performance_cache'):
            self._performance_cache = {}

    def _initialize_config_system(self):
        """åˆå§‹åŒ–é…ç½®ç³»ç»Ÿ - åº”æ€¥ç‰ˆæœ¬å®žçŽ°"""
        try:
            self.logger.debug("åˆå§‹åŒ–é…ç½®ç³»ç»Ÿ...")
            
            # éªŒè¯é…ç½®å®Œæ•´æ€§
            required_configs = ['name', 'execution_mode']
            for config_key in required_configs:
                if config_key not in self.config:
                    self.logger.warning(f"ç¼ºå°‘å¿…éœ€é…ç½®: {config_key}")
                    # è®¾ç½®é»˜è®¤å€¼
                    if config_key == 'execution_mode':
                        self.config[config_key] = 'realtime'
            
            return True
        except Exception as e:
            self.logger.error(f"é…ç½®ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: {e}")
            return False

    def _start_health_monitoring(self):
        """å¯åŠ¨å¥åº·ç›‘æŽ§"""
        try:
            self.logger.debug("å¯åŠ¨å¥åº·ç›‘æŽ§...")
            # ç®€åŒ–å®žçŽ° - åœ¨å®žé™…ç‰ˆæœ¬ä¸­è¿™é‡Œä¼šæœ‰å®šæ—¶å¥åº·æ£€æŸ¥
            self._last_health_check = datetime.now()
            return True
        except Exception as e:
            self.logger.error(f"å¥åº·ç›‘æŽ§å¯åŠ¨å¤±è´¥: {e}")
            return False

    def _validate_engine_integrity(self):
        """éªŒè¯å¼•æ“Žå®Œæ•´æ€§"""
        try:
            # æ£€æŸ¥å¿…éœ€ç»„ä»¶
            required_components = ['_strategies', '_engine_metrics', '_performance_metrics']
            for component in required_components:
                if not hasattr(self, component):
                    self.logger.error(f"ç¼ºå°‘å¿…éœ€ç»„ä»¶: {component}")
                    return False
            
            # æ£€æŸ¥ç­–ç•¥æ•°é‡
            if len(self._strategies) == 0:
                self.logger.warning("æœªåŠ è½½ä»»ä½•ç­–ç•¥")
                # ä¸è§†ä¸ºé”™è¯¯ï¼Œå…è®¸ç©ºç­–ç•¥å¼•æ“Žè¿è¡Œ
            
            return True
        except Exception as e:
            self.logger.error(f"å¼•æ“Žå®Œæ•´æ€§éªŒè¯å¤±è´¥: {e}")
            return False

    def _get_active_strategies_count(self):
        """èŽ·å–æ´»è·ƒç­–ç•¥æ•°é‡"""
        try:
            active_count = 0
            for strategy_name, strategy in self._strategies.items():
                if hasattr(strategy, 'initialized') and strategy.initialized:
                    active_count += 1
            return active_count
        except Exception as e:
            self.logger.error(f"èŽ·å–æ´»è·ƒç­–ç•¥æ•°é‡å¤±è´¥: {e}")
            return 0

    def _get_engine_metrics_dict(self):
        """èŽ·å–å¼•æ“ŽæŒ‡æ ‡å­—å…¸"""
        try:
            return {
                'total_strategies': self._engine_metrics.total_strategies,
                'active_strategies': self._engine_metrics.active_strategies,
                'signals_generated': self._engine_metrics.signals_generated,
                'signals_executed': self._engine_metrics.signals_executed,
                'execution_success_rate': self._engine_metrics.execution_success_rate,
                'average_signal_latency': self._engine_metrics.average_signal_latency,
                'memory_usage_mb': self._engine_metrics.memory_usage_mb,
                'cpu_usage_percent': self._engine_metrics.cpu_usage_percent,
                'uptime_seconds': (datetime.now() - self._last_state_change).total_seconds()
            }
        except Exception as e:
            self.logger.error(f"èŽ·å–å¼•æ“ŽæŒ‡æ ‡å¤±è´¥: {e}")
            return {}

    def _get_health_status(self):
        """èŽ·å–å¥åº·çŠ¶æ€"""
        try:
            return {
                'status': 'healthy',
                'last_check': self._last_health_check.isoformat(),
                'strategies_health': len(self._strategies) > 0,
                'performance_health': self._performance_metrics.error_count < 10
            }
        except Exception as e:
            self.logger.error(f"èŽ·å–å¥åº·çŠ¶æ€å¤±è´¥: {e}")
            return {'status': 'unknown'}

    def _create_strategy_context(self, processed_data):
        """åˆ›å»ºç­–ç•¥ä¸Šä¸‹æ–‡"""
        try:
            return StrategyContext(
                strategy_name="engine_context",
                market_data=processed_data.get('market_data', {}),
                portfolio_state={},  # ç®€åŒ–å®žçŽ°
                risk_parameters=self.config.get('risk_parameters', {}),
                execution_mode=self._execution_mode,
                timestamp=processed_data.get('timestamp', datetime.now()),
                metadata=processed_data.get('metadata', {})
            )
        except Exception as e:
            self.logger.error(f"åˆ›å»ºç­–ç•¥ä¸Šä¸‹æ–‡å¤±è´¥: {e}")
            # è¿”å›žåŸºæœ¬ä¸Šä¸‹æ–‡
            return StrategyContext(
                strategy_name="engine_context",
                market_data={},
                portfolio_state={},
                risk_parameters={},
                execution_mode=self._execution_mode
            )

    def _validate_and_optimize_signal(self, signal, strategy_context):
        """éªŒè¯å’Œä¼˜åŒ–ä¿¡å·"""
        try:
            # åŸºæœ¬ä¿¡å·éªŒè¯
            if not signal or not hasattr(signal, 'get_confidence'):
                return None
            
            # æ£€æŸ¥ç½®ä¿¡åº¦
            confidence = signal.get_confidence()
            if confidence < 0 or confidence > 1:
                self.logger.warning(f"ä¿¡å·ç½®ä¿¡åº¦å¼‚å¸¸: {confidence}")
                return None
            
            # ç®€åŒ–ä¼˜åŒ– - åœ¨å®žé™…ç‰ˆæœ¬ä¸­è¿™é‡Œä¼šæœ‰å¤æ‚çš„ä¼˜åŒ–é€»è¾‘
            return signal
            
        except Exception as e:
            self.logger.error(f"ä¿¡å·éªŒè¯ä¼˜åŒ–å¤±è´¥: {e}")
            return signal  # è¿”å›žåŽŸå§‹ä¿¡å·ä½œä¸ºé™çº§æ–¹æ¡ˆ

    def _update_signal_metrics(self, processing_time, signal_count):
        """æ›´æ–°ä¿¡å·æŒ‡æ ‡"""
        try:
            self._engine_metrics.signals_generated += signal_count
            self._engine_metrics.average_signal_latency = (
                self._engine_metrics.average_signal_latency * 0.9 + processing_time * 0.1
            )
            self._performance_metrics.call_count += signal_count
        except Exception as e:
            self.logger.error(f"æ›´æ–°ä¿¡å·æŒ‡æ ‡å¤±è´¥: {e}")

    def _handle_signal_generation_error(self, error):
        """å¤„ç†ä¿¡å·ç”Ÿæˆé”™è¯¯"""
        try:
            error_key = type(error).__name__
            self._error_count[error_key] += 1
            self._performance_metrics.error_count += 1
            
            # é”™è¯¯æ¢å¤é€»è¾‘
            if self._error_count[error_key] > 10:
                self.logger.warning(f"é”™è¯¯ {error_key} å‘ç”Ÿæ¬¡æ•°è¿‡å¤šï¼Œå°è¯•æ¢å¤")
                self._error_count[error_key] = 0  # é‡ç½®è®¡æ•°å™¨
        except Exception as e:
            self.logger.error(f"å¤„ç†ä¿¡å·ç”Ÿæˆé”™è¯¯å¤±è´¥: {e}")

    def _check_strategy_dependencies(self, strategy_name):
        """æ£€æŸ¥ç­–ç•¥ä¾èµ–"""
        try:
            dependencies = self._strategy_dependencies.get(strategy_name, [])
            for dep in dependencies:
                if dep not in self._strategies:
                    self.logger.warning(f"ç­–ç•¥ {strategy_name} çš„ä¾èµ– {dep} æœªæ‰¾åˆ°")
                    return False
            return True
        except Exception as e:
            self.logger.error(f"æ£€æŸ¥ç­–ç•¥ä¾èµ–å¤±è´¥ {strategy_name}: {e}")
            return True  # ä¾èµ–æ£€æŸ¥å¤±è´¥æ—¶å…è®¸ç­–ç•¥è¿è¡Œ

    def _handle_strategy_error(self, strategy_name, error):
        """å¤„ç†ç­–ç•¥é”™è¯¯"""
        try:
            self._recovery_attempts[strategy_name] += 1
            error_count = self._error_count[strategy_name]
            
            # é”™è¯¯è®¡æ•°å’Œæ¢å¤é€»è¾‘
            if error_count > 5 and self._recovery_attempts[strategy_name] < 3:
                self.logger.info(f"å°è¯•æ¢å¤ç­–ç•¥ {strategy_name}")
                # åœ¨å®žé™…ç‰ˆæœ¬ä¸­è¿™é‡Œä¼šæœ‰ç­–ç•¥æ¢å¤é€»è¾‘
        except Exception as e:
            self.logger.error(f"å¤„ç†ç­–ç•¥é”™è¯¯å¤±è´¥ {strategy_name}: {e}")

    def _update_engine_state(self, new_state: EngineState):
        """æ›´æ–°å¼•æ“ŽçŠ¶æ€"""
        old_state = self._engine_state
        self._engine_state = new_state
        self._last_state_change = datetime.now()
        
        self.logger.info(f"å¼•æ“ŽçŠ¶æ€å˜æ›´: {old_state.value} -> {new_state.value}")
        
        # æ¡ä»¶å‘å¸ƒçŠ¶æ€å˜æ›´äº‹ä»¶
        if self._enable_advanced_features:
            self._publish_engine_event("engine_state_change", {
                "old_state": old_state.value,
                "new_state": new_state.value,
                "timestamp": self._last_state_change.isoformat()
            })

    def _get_performance_metrics_dict(self):
        """å®‰å…¨èŽ·å–æ€§èƒ½æŒ‡æ ‡å­—å…¸"""
        try:
            if hasattr(self, '_performance_metrics') and hasattr(self._performance_metrics, 'to_dict'):
                return self._performance_metrics.to_dict()
            return {
                "execution_time": 0.0,
                "memory_usage": 0,
                "cpu_usage": 0.0,
                "call_count": 0,
                "error_count": 0,
                "cache_hit_rate": 0.0
            }
        except Exception as e:
            self.logger.error(f"èŽ·å–æ€§èƒ½æŒ‡æ ‡å¤±è´¥: {e}")
            return {}

# ç­–ç•¥å¼•æ“Žå·¥åŽ‚ç±» - æ•´åˆç‰ˆæœ¬
class StrategyEngineFactory:
    """ç­–ç•¥å¼•æ“Žå·¥åŽ‚ - æ”¯æŒåŠ¨æ€åˆ›å»ºå’Œç®¡ç†ç­–ç•¥å¼•æ“Ž"""
    
    _engines: Dict[str, StrategyEngine] = {}
    
    @classmethod
    def create_engine(cls, name: str, config: Dict[str, Any]) -> StrategyEngine:
        """åˆ›å»ºç­–ç•¥å¼•æ“Ž - æ•´åˆç‰ˆæœ¬"""
        try:
            # é»˜è®¤é…ç½®ï¼šç¨³å®šæ€§ä¼˜å…ˆ
            default_config = {
                "enable_advanced_features": False,
                "event_driven_architecture": False
            }
            default_config.update(config)
            
            engine = StrategyEngine(name, default_config)
            
            if engine.initialize():
                cls._engines[name] = engine
                return engine
            else:
                # å³ä½¿åˆå§‹åŒ–å¤±è´¥ï¼Œä¹Ÿè¿”å›žå¼•æ“Žå®žä¾‹
                cls._engines[name] = engine
                return engine
                
        except Exception as e:
            # åˆ›å»ºåŸºæœ¬å¼•æ“Žå®žä¾‹
            basic_engine = StrategyEngine(name, config)
            basic_engine.initialized = False
            cls._engines[name] = basic_engine
            return basic_engine
    
    @classmethod
    def create_advanced_engine(cls, name: str, config: Dict[str, Any]) -> StrategyEngine:
        """åˆ›å»ºé«˜çº§å¼•æ“Ž - å¯ç”¨æ‰€æœ‰é«˜çº§åŠŸèƒ½"""
        advanced_config = {
            "enable_advanced_features": True,
            "event_driven_architecture": True
        }
        advanced_config.update(config)
        
        engine = cls.create_engine(name, advanced_config)
        if engine.initialized:
            engine.enable_advanced_features()
        
        return engine

# è‡ªåŠ¨æ³¨å†ŒæŽ¥å£
try:
    from interfaces import InterfaceRegistry
    InterfaceRegistry.register_interface(StrategyEngine)
except ImportError:
    pass

__all__ = [
    'StrategyEngine',
    'StrategyEngineFactory',
    'EngineState',
    'ExecutionMode', 
    'EngineMetrics',
    'StrategyContext'
]