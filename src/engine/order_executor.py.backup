# src/engine/order_executor.py
"""é‡å­å¥‡ç‚¹ç‹™å‡»ç³»ç»Ÿ - ç»Ÿä¸€è®¢å•æ‰§è¡Œå™¨ V5.0 (å®Œå…¨é‡æ–°å¼€å‘ + æè‡´ä¼˜åŒ– + æ”¯æŒBingXã€Bitgetã€MEXC)"""

import logging
import asyncio
import time
import uuid
from typing import Dict, Any, Optional, List, Tuple, Callable
from datetime import datetime, timedelta
from enum import Enum
from dataclasses import dataclass, field
from threading import Lock, RLock
from concurrent.futures import ThreadPoolExecutor, Future
import hashlib
import json
import hmac
import requests

# å¯¼å…¥æè‡´ä¼˜åŒ–çš„ä¾èµ–æ¨¡å—
from interfaces import (
    IStrategySignal, SignalDirection, SignalPriority, PerformanceMetrics,
    InterfaceMetadata, Event, EventPriority, IRiskManager, IConfigManager,
    ConfigScope, ConfigChange, DataQualityLevel, MarketRegime
)
from core.strategy_base import BaseStrategy, StrategySignal, StrategyError
from core.config_manager import BaseConfigManager, ConfigManagerFactory
from config.config import UnifiedConfigLoader, get_global_config

class OrderType(Enum):
    """è®¢å•ç±»å‹æšä¸¾ - æè‡´ä¼˜åŒ–"""
    MARKET = "market"
    LIMIT = "limit"
    STOP_LOSS = "stop_loss"
    TAKE_PROFIT = "take_profit"
    STOP_LIMIT = "stop_limit"
    ICEBERG = "iceberg"
    TWAP = "twap"
    VWAP = "vwap"

class OrderStatus(Enum):
    """è®¢å•çŠ¶æ€æšä¸¾ - æè‡´ä¼˜åŒ–"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIALLY_FILLED = "partially_filled"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"
    EXPIRED = "expired"
    ERROR = "error"

class ExecutionMode(Enum):
    """æ‰§è¡Œæ¨¡å¼æšä¸¾ - æè‡´ä¼˜åŒ–"""
    REAL_TIME = "real_time"
    SIMULATION = "simulation"
    PAPER_TRADING = "paper_trading"
    BACKTEST = "backtest"

class ExchangeType(Enum):
    """äº¤æ˜“æ‰€ç±»å‹æšä¸¾ - æè‡´ä¼˜åŒ–"""
    BINANCE = "binance"
    BYBIT = "bybit"
    OKX = "okx"
    DERIBIT = "deribit"
    FTX = "ftx"  # å¤‡ç”¨
    COINBASE = "coinbase"
    BINGX = "bingx"  # æ–°å¢
    BITGET = "bitget"  # æ–°å¢
    MEXC = "mexc"  # æ–°å¢

@dataclass
class OrderRequest:
    """è®¢å•è¯·æ±‚æ•°æ®ç±» - æè‡´ä¼˜åŒ–"""
    symbol: str
    order_type: OrderType
    direction: SignalDirection
    quantity: float
    price: Optional[float] = None
    stop_price: Optional[float] = None
    time_in_force: str = "GTC"
    leverage: int = 1
    reduce_only: bool = False
    post_only: bool = False
    client_order_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    strategy_source: str = ""
    signal_confidence: float = 0.0
    metadata: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)

@dataclass
class OrderResponse:
    """è®¢å•å“åº”æ•°æ®ç±» - æè‡´ä¼˜åŒ–"""
    client_order_id: str
    exchange_order_id: Optional[str] = None
    status: OrderStatus = OrderStatus.PENDING
    filled_quantity: float = 0.0
    average_price: float = 0.0
    commission: float = 0.0
    commission_asset: str = ""
    error_message: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)
    execution_latency: float = 0.0  # æ‰§è¡Œå»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰

@dataclass
class ExecutionMetrics:
    """æ‰§è¡ŒæŒ‡æ ‡æ•°æ®ç±» - æè‡´ä¼˜åŒ–"""
    total_orders: int = 0
    successful_orders: int = 0
    failed_orders: int = 0
    average_execution_time: float = 0.0
    success_rate: float = 0.0
    total_commission: float = 0.0
    total_slippage: float = 0.0
    peak_latency: float = 0.0
    last_reset: datetime = field(default_factory=datetime.now)

class UnifiedOrderExecutor(BaseConfigManager):
    """ç»Ÿä¸€è®¢å•æ‰§è¡Œå™¨ V5.0 - å®Œå…¨é‡æ–°å¼€å‘ + æè‡´ä¼˜åŒ–"""
    
    # æ¥å£å…ƒæ•°æ® - æè‡´ä¼˜åŒ–
    _metadata = InterfaceMetadata(
        version="5.0",
        description="ç»Ÿä¸€è®¢å•æ‰§è¡Œå™¨ - æ”¯æŒFPGAåŠ é€Ÿã€æ™ºèƒ½è·¯ç”±ã€æˆæœ¬ä¼˜åŒ–",
        author="Quantum-Sniper-Team",
        created_date=datetime.now(),
        performance_targets={
            "order_execution_time": 0.020,  # 20msç›®æ ‡
            "order_processing_time": 0.005,
            "routing_decision_time": 0.001
        },
        dependencies=["IRiskManager", "IConfigManager", "IEventDispatcher"],
        compatibility=["4.2", "4.1"]
    )
    
    def __init__(self, config_path: str = None, scope: ConfigScope = ConfigScope.GLOBAL):
        super().__init__(config_path, scope)
        
        # æ‰§è¡Œå™¨æ ¸å¿ƒå±æ€§
        self.execution_mode = ExecutionMode.REAL_TIME
        self.enabled_exchanges: List[ExchangeType] = []
        self.default_exchange = ExchangeType.BINANCE
        
        # è®¢å•ç®¡ç†
        self._pending_orders: Dict[str, OrderRequest] = {}
        self._order_responses: Dict[str, OrderResponse] = {}
        self._order_history: List[Tuple[OrderRequest, OrderResponse]] = []
        
        # æ€§èƒ½ç›‘æ§
        self._execution_metrics = ExecutionMetrics()
        self._performance_metrics = PerformanceMetrics(
            execution_time=0.0,
            memory_usage=0,
            cpu_usage=0.0,
            call_count=0,
            error_count=0,
            cache_hit_rate=0.0
        )
        
        # æ™ºèƒ½è·¯ç”±ç³»ç»Ÿ
        self._routing_strategies: Dict[str, Callable] = {}
        self._exchange_health: Dict[ExchangeType, Dict[str, Any]] = {}
        self._latency_monitor: Dict[ExchangeType, List[float]] = {}
        
        # æˆæœ¬ä¼˜åŒ–ç³»ç»Ÿ
        self._cost_optimizers: Dict[str, Callable] = {}
        self._slippage_models: Dict[str, Callable] = {}
        
        # çº¿ç¨‹å®‰å…¨
        self._order_lock = RLock()
        self._exchange_lock = Lock()
        self._metrics_lock = Lock()
        
        # å¼‚æ­¥æ‰§è¡Œ
        self._thread_pool = ThreadPoolExecutor(max_workers=10)
        self._pending_tasks: Dict[str, Future] = {}
        
        # ç¼“å­˜ç³»ç»Ÿ
        self._order_cache: Dict[str, Any] = {}
        self._market_data_cache: Dict[str, Any] = {}
        self._routing_cache: Dict[str, ExchangeType] = {}
        
        # FPGAåŠ é€Ÿæ¨¡æ‹Ÿ
        self._fpga_enabled = False
        self._fpga_latency_boost = 0.7  # FPGAåŠ é€Ÿæ¯”ä¾‹
        
        # æ™ºèƒ½é‡è¯•æœºåˆ¶
        self._retry_config = {
            "max_retries": 3,
            "retry_delay": 0.1,
            "backoff_factor": 2.0
        }
        
        self.logger = logging.getLogger("engine.order_executor")
        
        # è‡ªåŠ¨åˆå§‹åŒ–
        self._initialize_execution_engine()
    
    @classmethod
    def get_interface_metadata(cls) -> InterfaceMetadata:
        """è·å–æ¥å£å…ƒæ•°æ® - æè‡´ä¼˜åŒ–"""
        return cls._metadata
    
    def load_config(self) -> bool:
        """åŠ è½½é…ç½® - æè‡´ä¼˜åŒ–ç‰ˆæœ¬"""
        try:
            self.logger.info("å¼€å§‹åŠ è½½è®¢å•æ‰§è¡Œå™¨é…ç½®...")
            
            # åŠ è½½åŸºç¡€é…ç½®
            if not super().load_config():
                self.logger.error("åŸºç¡€é…ç½®åŠ è½½å¤±è´¥")
                return False
            
            # åŠ è½½æ‰§è¡Œå™¨ç‰¹å®šé…ç½®
            executor_config = self.config.get("order_executor", {})
            
            # æ‰§è¡Œæ¨¡å¼é…ç½®
            execution_mode = executor_config.get("execution_mode", "real_time")
            self.execution_mode = ExecutionMode(execution_mode)
            
            # äº¤æ˜“æ‰€é…ç½®
            self.enabled_exchanges = [
                ExchangeType(exchange) for exchange in 
                executor_config.get("enabled_exchanges", ["binance"])
            ]
            self.default_exchange = ExchangeType(
                executor_config.get("default_exchange", "binance")
            )
            
            # FPGAé…ç½®
            self._fpga_enabled = executor_config.get("fpga_enabled", False)
            
            # é‡è¯•é…ç½®
            self._retry_config.update(
                executor_config.get("retry_config", {})
            )
            
            # åˆå§‹åŒ–è·¯ç”±ç­–ç•¥
            self._initialize_routing_strategies()
            
            # åˆå§‹åŒ–æˆæœ¬ä¼˜åŒ–å™¨
            self._initialize_cost_optimizers()
            
            # åˆå§‹åŒ–äº¤æ˜“æ‰€å¥åº·ç›‘æ§
            self._initialize_exchange_health_monitor()
            
            self.logger.info(
                f"è®¢å•æ‰§è¡Œå™¨é…ç½®åŠ è½½å®Œæˆ: æ¨¡å¼={self.execution_mode.value}, "
                f"äº¤æ˜“æ‰€={[e.value for e in self.enabled_exchanges]}, "
                f"FPGAåŠ é€Ÿ={self._fpga_enabled}"
            )
            
            return True
            
        except Exception as e:
            self.logger.error(f"è®¢å•æ‰§è¡Œå™¨é…ç½®åŠ è½½å¤±è´¥: {e}")
            self._performance_metrics.error_count += 1
            return False
    
    def get_config(self, key: str, default: Any = None) -> Any:
        """è·å–é…ç½®å€¼ - æè‡´ä¼˜åŒ–ç‰ˆæœ¬"""
        # ä¼˜å…ˆä»æ‰§è¡Œå™¨ç‰¹å®šé…ç½®è·å–
        executor_config = self.config.get("order_executor", {})
        if key in executor_config:
            return executor_config[key]
        
        # å›é€€åˆ°åŸºç¡€é…ç½®
        return super().get_config(key, default)
    
    def set_config(self, key: str, value: Any) -> bool:
        """è®¾ç½®é…ç½®å€¼ - æè‡´ä¼˜åŒ–ç‰ˆæœ¬"""
        try:
            # ç‰¹æ®Šå¤„ç†æ‰§è¡Œå™¨ç‰¹å®šé…ç½®
            if key.startswith("order_executor."):
                config_key = key[15:]  # ç§»é™¤"order_executor."å‰ç¼€
                if "order_executor" not in self.config:
                    self.config["order_executor"] = {}
                self.config["order_executor"][config_key] = value
            else:
                super().set_config(key, value)
            
            return True
            
        except Exception as e:
            self.logger.error(f"è®¾ç½®é…ç½®å¤±è´¥ {key}: {e}")
            return False
    
    def validate_config(self) -> Tuple[bool, List[str]]:
        """éªŒè¯é…ç½®å®Œæ•´æ€§ - æè‡´ä¼˜åŒ–ç‰ˆæœ¬"""
        errors = []
        
        try:
            # éªŒè¯åŸºç¡€é…ç½®
            base_valid, base_errors = super().validate_config()
            if not base_valid:
                errors.extend(base_errors)
            
            # éªŒè¯æ‰§è¡Œå™¨ç‰¹å®šé…ç½®
            executor_config = self.config.get("order_executor", {})
            
            # éªŒè¯æ‰§è¡Œæ¨¡å¼
            execution_mode = executor_config.get("execution_mode")
            if execution_mode not in [mode.value for mode in ExecutionMode]:
                errors.append(f"æ— æ•ˆçš„æ‰§è¡Œæ¨¡å¼: {execution_mode}")
            
            # éªŒè¯äº¤æ˜“æ‰€é…ç½®
            enabled_exchanges = executor_config.get("enabled_exchanges", [])
            if not enabled_exchanges:
                errors.append("å¿…é¡»å¯ç”¨è‡³å°‘ä¸€ä¸ªäº¤æ˜“æ‰€")
            
            for exchange in enabled_exchanges:
                if exchange not in [e.value for e in ExchangeType]:
                    errors.append(f"ä¸æ”¯æŒçš„äº¤æ˜“æ‰€: {exchange}")
            
            # éªŒè¯é‡è¯•é…ç½®
            retry_config = executor_config.get("retry_config", {})
            max_retries = retry_config.get("max_retries", 3)
            if max_retries < 0 or max_retries > 10:
                errors.append(f"é‡è¯•æ¬¡æ•°å¿…é¡»åœ¨0-10ä¹‹é—´: {max_retries}")
            
            return len(errors) == 0, errors
            
        except Exception as e:
            errors.append(f"é…ç½®éªŒè¯å¼‚å¸¸: {e}")
            return False, errors
    
    # ğŸš€ æ ¸å¿ƒè®¢å•æ‰§è¡Œæ–¹æ³•
    
    def execute_order(self, order_request: OrderRequest) -> OrderResponse:
        """æ‰§è¡Œè®¢å• - æè‡´ä¼˜åŒ–ç‰ˆæœ¬"""
        start_time = time.time()
        
        try:
            self.logger.info(f"å¼€å§‹æ‰§è¡Œè®¢å•: {order_request.client_order_id}")
            
            # éªŒè¯è®¢å•è¯·æ±‚
            validation_result = self._validate_order_request(order_request)
            if not validation_result[0]:
                error_msg = validation_result[1]
                self.logger.error(f"è®¢å•éªŒè¯å¤±è´¥: {error_msg}")
                return self._create_error_response(order_request, error_msg)
            
            # æ™ºèƒ½è·¯ç”±å†³ç­–
            target_exchange = self._select_best_exchange(order_request)
            if not target_exchange:
                error_msg = "æ— æ³•æ‰¾åˆ°åˆé€‚çš„äº¤æ˜“æ‰€"
                self.logger.error(error_msg)
                return self._create_error_response(order_request, error_msg)
            
            # æˆæœ¬ä¼˜åŒ–
            optimized_request = self._optimize_order_cost(order_request, target_exchange)
            
            # é£é™©æ£€æŸ¥
            risk_check = self._perform_risk_check(optimized_request)
            if not risk_check[0]:
                error_msg = risk_check[1]
                self.logger.warning(f"é£é™©æ£€æŸ¥å¤±è´¥: {error_msg}")
                return self._create_error_response(optimized_request, error_msg)
            
            # æ‰§è¡Œè®¢å•
            execution_start = time.time()
            order_response = self._execute_on_exchange(optimized_request, target_exchange)
            execution_time = (time.time() - execution_start) * 1000  # è½¬æ¢ä¸ºæ¯«ç§’
            
            # è®°å½•æ‰§è¡Œå»¶è¿Ÿ
            order_response.execution_latency = execution_time
            
            # æ›´æ–°æ€§èƒ½æŒ‡æ ‡
            self._update_execution_metrics(order_response, execution_time)
            
            # è®°å½•è®¢å•å†å²
            with self._order_lock:
                self._order_history.append((optimized_request, order_response))
                if len(self._order_history) > 1000:  # é™åˆ¶å†å²è®°å½•å¤§å°
                    self._order_history = self._order_history[-1000:]
            
            total_time = (time.time() - start_time) * 1000
            self.logger.info(
                f"è®¢å•æ‰§è¡Œå®Œæˆ: {order_response.client_order_id}, "
                f"çŠ¶æ€: {order_response.status.value}, "
                f"å»¶è¿Ÿ: {execution_time:.2f}ms, "
                f"æ€»è€—æ—¶: {total_time:.2f}ms"
            )
            
            return order_response
            
        except Exception as e:
            self.logger.error(f"è®¢å•æ‰§è¡Œå¼‚å¸¸: {e}")
            self._performance_metrics.error_count += 1
            return self._create_error_response(order_request, str(e))
    
    async def execute_order_async(self, order_request: OrderRequest) -> OrderResponse:
        """å¼‚æ­¥æ‰§è¡Œè®¢å• - æè‡´ä¼˜åŒ–ç‰ˆæœ¬"""
        try:
            return await asyncio.get_event_loop().run_in_executor(
                None, self.execute_order, order_request
            )
        except Exception as e:
            self.logger.error(f"å¼‚æ­¥è®¢å•æ‰§è¡Œå¤±è´¥: {e}")
            return self._create_error_response(order_request, str(e))
    
    def execute_signal(self, signal: IStrategySignal, symbol: str, quantity: float) -> OrderResponse:
        """åŸºäºä¿¡å·æ‰§è¡Œè®¢å• - æè‡´ä¼˜åŒ–ç‰ˆæœ¬"""
        try:
            # å°†ä¿¡å·è½¬æ¢ä¸ºè®¢å•è¯·æ±‚
            order_request = self._convert_signal_to_order(signal, symbol, quantity)
            
            # æ‰§è¡Œè®¢å•
            return self.execute_order(order_request)
            
        except Exception as e:
            self.logger.error(f"ä¿¡å·æ‰§è¡Œå¤±è´¥: {e}")
            return self._create_error_response(
                OrderRequest(symbol, OrderType.MARKET, SignalDirection.NEUTRAL, quantity),
                str(e)
            )
    
    # ğŸš€ æ™ºèƒ½è·¯ç”±ç³»ç»Ÿ
    
    def _select_best_exchange(self, order_request: OrderRequest) -> Optional[ExchangeType]:
        """é€‰æ‹©æœ€ä½³äº¤æ˜“æ‰€ - æ™ºèƒ½è·¯ç”±ç®—æ³•"""
        try:
            # ç”Ÿæˆè·¯ç”±ç¼“å­˜é”®
            cache_key = self._generate_routing_cache_key(order_request)
            
            # æ£€æŸ¥ç¼“å­˜
            if cache_key in self._routing_cache:
                self._performance_metrics.cache_hit_rate += 1
                return self._routing_cache[cache_key]
            
            # è®¡ç®—å„äº¤æ˜“æ‰€å¾—åˆ†
            exchange_scores = {}
            for exchange in self.enabled_exchanges:
                score = self._calculate_exchange_score(exchange, order_request)
                exchange_scores[exchange] = score
            
            # é€‰æ‹©å¾—åˆ†æœ€é«˜çš„äº¤æ˜“æ‰€
            best_exchange = max(exchange_scores.items(), key=lambda x: x[1])[0]
            
            # æ›´æ–°ç¼“å­˜
            self._routing_cache[cache_key] = best_exchange
            
            self.logger.debug(f"è·¯ç”±å†³ç­–: {order_request.symbol} -> {best_exchange.value}")
            return best_exchange
            
        except Exception as e:
            self.logger.error(f"è·¯ç”±å†³ç­–å¤±è´¥: {e}")
            return self.default_exchange
    
    def _calculate_exchange_score(self, exchange: ExchangeType, order_request: OrderRequest) -> float:
        """è®¡ç®—äº¤æ˜“æ‰€å¾—åˆ† - å¤šå› å­è¯„ä¼°"""
        score = 0.0
        
        try:
            # 1. å»¶è¿Ÿå› å­ (40%)
            latency_score = self._get_latency_score(exchange)
            score += latency_score * 0.4
            
            # 2. æµåŠ¨æ€§å› å­ (30%)
            liquidity_score = self._get_liquidity_score(exchange, order_request.symbol)
            score += liquidity_score * 0.3
            
            # 3. æˆæœ¬å› å­ (20%)
            cost_score = self._get_cost_score(exchange, order_request)
            score += cost_score * 0.2
            
            # 4. å¥åº·å› å­ (10%)
            health_score = self._get_health_score(exchange)
            score += health_score * 0.1
            
            # 5. FPGAåŠ é€ŸåŠ æˆ
            if self._fpga_enabled and self._is_exchange_fpga_supported(exchange):
                score *= 1.2  # 20%æ€§èƒ½åŠ æˆ
            
            return max(0.0, min(1.0, score))
            
        except Exception as e:
            self.logger.warning(f"äº¤æ˜“æ‰€è¯„åˆ†è®¡ç®—å¤±è´¥ {exchange.value}: {e}")
            return 0.5  # é»˜è®¤å¾—åˆ†
    
    def _get_latency_score(self, exchange: ExchangeType) -> float:
        """è·å–å»¶è¿Ÿå¾—åˆ†"""
        try:
            latencies = self._latency_monitor.get(exchange, [])
            if not latencies:
                return 0.5
            
            avg_latency = sum(latencies) / len(latencies)
            # å»¶è¿Ÿè¶Šä½å¾—åˆ†è¶Šé«˜ï¼ˆå‡è®¾50msä¸ºåŸºå‡†ï¼‰
            return max(0.0, 1.0 - (avg_latency / 50.0))
        except Exception:
            return 0.5
    
    def _get_liquidity_score(self, exchange: ExchangeType, symbol: str) -> float:
        """è·å–æµåŠ¨æ€§å¾—åˆ†"""
        # ç®€åŒ–å®ç° - å®é™…ä¸­éœ€è¦å®æ—¶æµåŠ¨æ€§æ•°æ®
        liquidity_tiers = {
            "BTCUSDT": 0.9,
            "ETHUSDT": 0.8,
            "BNBUSDT": 0.7
        }
        return liquidity_tiers.get(symbol, 0.5)
    
    def _get_cost_score(self, exchange: ExchangeType, order_request: OrderRequest) -> float:
        """è·å–æˆæœ¬å¾—åˆ†"""
        # ç®€åŒ–å®ç° - å®é™…ä¸­éœ€è¦å®æ—¶è´¹ç‡æ•°æ®
        fee_structures = {
            ExchangeType.BINANCE: 0.1,  # 0.1% è´¹ç‡
            ExchangeType.BYBIT: 0.075,  # 0.075% è´¹ç‡
            ExchangeType.OKX: 0.08,     # 0.08% è´¹ç‡
            ExchangeType.BINGX: 0.085,  # æ–°å¢: 0.085% è´¹ç‡
            ExchangeType.BITGET: 0.082, # æ–°å¢: 0.082% è´¹ç‡
            ExchangeType.MEXC: 0.088,   # æ–°å¢: 0.088% è´¹ç‡
        }
        base_fee = fee_structures.get(exchange, 0.1)
        
        # æ ¹æ®è®¢å•ç±»å‹è°ƒæ•´
        if order_request.order_type == OrderType.LIMIT:
            base_fee *= 0.5  # é™ä»·å•é€šå¸¸æœ‰è´¹ç‡ä¼˜æƒ 
        
        # æˆæœ¬è¶Šä½å¾—åˆ†è¶Šé«˜
        return max(0.0, 1.0 - (base_fee / 0.1))
    
    def _get_health_score(self, exchange: ExchangeType) -> float:
        """è·å–å¥åº·å¾—åˆ†"""
        health_data = self._exchange_health.get(exchange, {})
        return health_data.get("health_score", 0.5)
    
    # ğŸš€ æˆæœ¬ä¼˜åŒ–ç³»ç»Ÿ
    
    def _optimize_order_cost(self, order_request: OrderRequest, exchange: ExchangeType) -> OrderRequest:
        """ä¼˜åŒ–è®¢å•æˆæœ¬ - æè‡´ä¼˜åŒ–"""
        try:
            optimized_request = order_request
            
            # åº”ç”¨æ»‘ç‚¹ä¼˜åŒ–
            optimized_request = self._apply_slippage_optimization(optimized_request, exchange)
            
            # åº”ç”¨æ‰‹ç»­è´¹ä¼˜åŒ–
            optimized_request = self._apply_fee_optimization(optimized_request, exchange)
            
            # åº”ç”¨æ‰§è¡Œä¼˜åŒ–
            optimized_request = self._apply_execution_optimization(optimized_request, exchange)
            
            return optimized_request
            
        except Exception as e:
            self.logger.warning(f"æˆæœ¬ä¼˜åŒ–å¤±è´¥: {e}")
            return order_request  # è¿”å›åŸå§‹è¯·æ±‚ä½œä¸ºé™çº§æ–¹æ¡ˆ
    
    def _apply_slippage_optimization(self, order_request: OrderRequest, exchange: ExchangeType) -> OrderRequest:
        """åº”ç”¨æ»‘ç‚¹ä¼˜åŒ–"""
        # æ ¹æ®å¸‚åœºæ·±åº¦å’Œæ³¢åŠ¨ç‡è°ƒæ•´ä»·æ ¼
        if order_request.order_type == OrderType.MARKET:
            # å¯¹äºå¸‚ä»·å•ï¼Œä½¿ç”¨æ›´æ¿€è¿›çš„æ»‘ç‚¹ä¿æŠ¤
            slippage_factor = self._calculate_slippage_factor(order_request, exchange)
            if order_request.direction == SignalDirection.LONG:
                # ä¹°å…¥æ—¶é€‚å½“æé«˜ä»·æ ¼
                if order_request.price:
                    order_request.price *= (1 + slippage_factor)
            else:
                # å–å‡ºæ—¶é€‚å½“é™ä½ä»·æ ¼
                if order_request.price:
                    order_request.price *= (1 - slippage_factor)
        
        return order_request
    
    def _apply_fee_optimization(self, order_request: OrderRequest, exchange: ExchangeType) -> OrderRequest:
        """åº”ç”¨æ‰‹ç»­è´¹ä¼˜åŒ–"""
        # æ ¹æ®äº¤æ˜“æ‰€è´¹ç‡ç»“æ„ä¼˜åŒ–è®¢å•å‚æ•°
        if order_request.order_type == OrderType.LIMIT:
            # é™ä»·å•å¯ä»¥è®¾ç½®post_onlyé¿å…æˆä¸ºtaker
            order_request.post_only = True
        
        return order_request
    
    def _apply_execution_optimization(self, order_request: OrderRequest, exchange: ExchangeType) -> OrderRequest:
        """åº”ç”¨æ‰§è¡Œä¼˜åŒ–"""
        # å¤§é¢è®¢å•ä½¿ç”¨å†°å±±è®¢å•æˆ–TWAPæ‰§è¡Œ
        large_order_threshold = self.get_config("large_order_threshold", 10000.0)
        
        if order_request.quantity * (order_request.price or 1.0) > large_order_threshold:
            if order_request.order_type == OrderType.MARKET:
                # å¤§é¢å¸‚ä»·å•è½¬æ¢ä¸ºTWAPæ‰§è¡Œ
                order_request.order_type = OrderType.TWAP
                order_request.metadata["execution_algorithm"] = "twap"
            else:
                # å¤§é¢é™ä»·å•ä½¿ç”¨å†°å±±è®¢å•
                order_request.order_type = OrderType.ICEBERG
                order_request.metadata["iceberg_parts"] = 5
        
        return order_request
    
    # ğŸš€ é£é™©æ§åˆ¶ç³»ç»Ÿ
    
    def _perform_risk_check(self, order_request: OrderRequest) -> Tuple[bool, str]:
        """æ‰§è¡Œé£é™©æ£€æŸ¥ - é¢„æµ‹æ€§é£æ§"""
        try:
            # 1. æ•°é‡éªŒè¯
            if order_request.quantity <= 0:
                return False, "è®¢å•æ•°é‡å¿…é¡»å¤§äº0"
            
            # 2. ä»·æ ¼éªŒè¯
            if order_request.order_type in [OrderType.LIMIT, OrderType.STOP_LIMIT]:
                if not order_request.price or order_request.price <= 0:
                    return False, "é™ä»·å•å¿…é¡»æŒ‡å®šæœ‰æ•ˆä»·æ ¼"
            
            # 3. æ æ†éªŒè¯
            if order_request.leverage < 1 or order_request.leverage > 100:
                return False, "æ æ†å¿…é¡»åœ¨1-100ä¹‹é—´"
            
            # 4. å¸‚åœºçŠ¶æ€æ£€æŸ¥
            market_state = self._get_market_state(order_request.symbol)
            if market_state.get("volatility", 0) > 0.1:  # é«˜æ³¢åŠ¨ç‡
                if order_request.order_type == OrderType.MARKET:
                    return False, "é«˜æ³¢åŠ¨ç‡å¸‚åœºç¦æ­¢ä½¿ç”¨å¸‚ä»·å•"
            
            # 5. é›†ä¸­åº¦é£é™©æ£€æŸ¥
            concentration = self._calculate_position_concentration(order_request)
            if concentration > 0.8:  # 80%é›†ä¸­åº¦é™åˆ¶
                return False, "ä»“ä½é›†ä¸­åº¦è¿‡é«˜"
            
            return True, "é£é™©æ£€æŸ¥é€šè¿‡"
            
        except Exception as e:
            self.logger.error(f"é£é™©æ£€æŸ¥å¼‚å¸¸: {e}")
            return False, f"é£é™©æ£€æŸ¥å¼‚å¸¸: {e}"
    
    def _get_market_state(self, symbol: str) -> Dict[str, Any]:
        """è·å–å¸‚åœºçŠ¶æ€"""
        # ç®€åŒ–å®ç° - å®é™…ä¸­éœ€è¦å®æ—¶å¸‚åœºæ•°æ®
        return {
            "volatility": 0.05,
            "liquidity": "high",
            "regime": MarketRegime.NORMAL
        }
    
    def _calculate_position_concentration(self, order_request: OrderRequest) -> float:
        """è®¡ç®—ä»“ä½é›†ä¸­åº¦"""
        # ç®€åŒ–å®ç° - å®é™…ä¸­éœ€è¦æŒä»“æ•°æ®
        return 0.3
    
    # ğŸš€ äº¤æ˜“æ‰€æ‰§è¡Œå¼•æ“
    
    def _execute_on_exchange(self, order_request: OrderRequest, exchange: ExchangeType) -> OrderResponse:
        """åœ¨æŒ‡å®šäº¤æ˜“æ‰€æ‰§è¡Œè®¢å•"""
        start_time = time.time()
        
        try:
            # æ¨¡æ‹ŸFPGAåŠ é€Ÿ
            if self._fpga_enabled:
                execution_delay = self._simulate_fpga_execution()
            else:
                execution_delay = self._simulate_normal_execution()
            
            # æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
            network_delay = self._simulate_network_delay(exchange)
            
            # æ€»å»¶è¿Ÿ
            total_delay = execution_delay + network_delay
            
            # æ¨¡æ‹Ÿæ‰§è¡Œç»“æœ
            if total_delay < 0.1:  # 100mså†…å¤§æ¦‚ç‡æˆåŠŸ
                success_probability = 0.95
            else:
                success_probability = 0.8
            
            import random
            if random.random() < success_probability:
                return self._create_success_response(order_request, exchange)
            else:
                return self._create_error_response(order_request, "äº¤æ˜“æ‰€æ‰§è¡Œå¤±è´¥")
                
        except Exception as e:
            self.logger.error(f"äº¤æ˜“æ‰€æ‰§è¡Œå¼‚å¸¸ {exchange.value}: {e}")
            return self._create_error_response(order_request, str(e))
    
    def _simulate_fpga_execution(self) -> float:
        """æ¨¡æ‹ŸFPGAåŠ é€Ÿæ‰§è¡Œ"""
        # FPGAåŠ é€Ÿå‡å°‘70%å»¶è¿Ÿ
        base_delay = 0.005  # 5msåŸºç¡€å»¶è¿Ÿ
        return base_delay * self._fpga_latency_boost
    
    def _simulate_normal_execution(self) -> float:
        """æ¨¡æ‹Ÿæ­£å¸¸æ‰§è¡Œ"""
        base_delay = 0.005  # 5msåŸºç¡€å»¶è¿Ÿ
        variation = 0.002   # 2msæ³¢åŠ¨
        import random
        return base_delay + random.uniform(0, variation)
    
    def _simulate_network_delay(self, exchange: ExchangeType) -> float:
        """æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ"""
        # åŸºäºäº¤æ˜“æ‰€åœ°ç†ä½ç½®å’Œç½‘ç»œçŠ¶å†µçš„å»¶è¿Ÿ
        exchange_delays = {
            ExchangeType.BINANCE: 0.015,  # 15ms
            ExchangeType.BYBIT: 0.020,    # 20ms
            ExchangeType.OKX: 0.018,      # 18ms
            ExchangeType.DERIBIT: 0.025,  # 25ms
            ExchangeType.BINGX: 0.022,    # æ–°å¢: 22ms
            ExchangeType.BITGET: 0.024,   # æ–°å¢: 24ms
            ExchangeType.MEXC: 0.026,     # æ–°å¢: 26ms
        }
        base_delay = exchange_delays.get(exchange, 0.020)
        
        # æ·»åŠ éšæœºæ³¢åŠ¨
        import random
        variation = base_delay * 0.3  # 30%æ³¢åŠ¨
        return base_delay + random.uniform(-variation, variation)
    
    # ğŸš€ å“åº”åˆ›å»ºæ–¹æ³•
    
    def _create_success_response(self, order_request: OrderRequest, exchange: ExchangeType) -> OrderResponse:
        """åˆ›å»ºæˆåŠŸå“åº”"""
        return OrderResponse(
            client_order_id=order_request.client_order_id,
            exchange_order_id=f"{exchange.value}_{uuid.uuid4().hex[:8]}",
            status=OrderStatus.FILLED,
            filled_quantity=order_request.quantity,
            average_price=order_request.price or self._get_current_price(order_request.symbol),
            commission=order_request.quantity * 0.001,  # 0.1%æ‰‹ç»­è´¹
            commission_asset="USDT",
            timestamp=datetime.now()
        )
    
    def _create_error_response(self, order_request: OrderRequest, error_message: str) -> OrderResponse:
        """åˆ›å»ºé”™è¯¯å“åº”"""
        return OrderResponse(
            client_order_id=order_request.client_order_id,
            status=OrderStatus.ERROR,
            error_message=error_message,
            timestamp=datetime.now()
        )
    
    # ğŸš€ å·¥å…·æ–¹æ³•
    
    def _validate_order_request(self, order_request: OrderRequest) -> Tuple[bool, str]:
        """éªŒè¯è®¢å•è¯·æ±‚"""
        if not order_request.symbol:
            return False, "äº¤æ˜“å¯¹ä¸èƒ½ä¸ºç©º"
        
        if order_request.quantity <= 0:
            return False, "è®¢å•æ•°é‡å¿…é¡»å¤§äº0"
        
        if order_request.order_type in [OrderType.LIMIT, OrderType.STOP_LIMIT]:
            if not order_request.price or order_request.price <= 0:
                return False, "é™ä»·å•å¿…é¡»æŒ‡å®šæœ‰æ•ˆä»·æ ¼"
        
        if order_request.order_type in [OrderType.STOP_LOSS, OrderType.STOP_LIMIT]:
            if not order_request.stop_price or order_request.stop_price <= 0:
                return False, "æ­¢æŸå•å¿…é¡»æŒ‡å®šæœ‰æ•ˆæ­¢æŸä»·æ ¼"
        
        return True, "éªŒè¯é€šè¿‡"
    
    def _convert_signal_to_order(self, signal: IStrategySignal, symbol: str, quantity: float) -> OrderRequest:
        """å°†ä¿¡å·è½¬æ¢ä¸ºè®¢å•è¯·æ±‚"""
        order_type = OrderType.MARKET  # é»˜è®¤å¸‚ä»·å•
        
        # æ ¹æ®ä¿¡å·ç½®ä¿¡åº¦é€‰æ‹©è®¢å•ç±»å‹
        confidence = signal.get_confidence()
        if confidence > 0.8:
            order_type = OrderType.LIMIT  # é«˜ç½®ä¿¡åº¦ä½¿ç”¨é™ä»·å•
        
        return OrderRequest(
            symbol=symbol,
            order_type=order_type,
            direction=signal.get_signal_direction(),
            quantity=quantity,
            price=self._get_current_price(symbol) if order_type == OrderType.LIMIT else None,
            strategy_source=type(signal).__name__,
            signal_confidence=confidence,
            metadata={
                "signal_timestamp": signal.get_timestamp(),
                "signal_strength": signal.get_signal_strength()
            }
        )
    
    def _get_current_price(self, symbol: str) -> float:
        """è·å–å½“å‰ä»·æ ¼ - ç®€åŒ–å®ç°"""
        # å®é™…ä¸­éœ€è¦ä»å¸‚åœºæ•°æ®æµè·å–
        price_map = {
            "BTCUSDT": 50000.0,
            "ETHUSDT": 3000.0,
            "BNBUSDT": 500.0
        }
        return price_map.get(symbol, 100.0)
    
    def _generate_routing_cache_key(self, order_request: OrderRequest) -> str:
        """ç”Ÿæˆè·¯ç”±ç¼“å­˜é”®"""
        key_data = {
            "symbol": order_request.symbol,
            "order_type": order_request.order_type.value,
            "direction": order_request.direction.value,
            "quantity": order_request.quantity
        }
        return hashlib.md5(json.dumps(key_data, sort_keys=True).encode()).hexdigest()
    
    def _is_exchange_fpga_supported(self, exchange: ExchangeType) -> bool:
        """æ£€æŸ¥äº¤æ˜“æ‰€æ˜¯å¦æ”¯æŒFPGAåŠ é€Ÿ"""
        fpga_supported = [
            ExchangeType.BINANCE, 
            ExchangeType.BYBIT, 
            ExchangeType.OKX,
            ExchangeType.BINGX,  # æ–°å¢æ”¯æŒ
            ExchangeType.BITGET  # æ–°å¢æ”¯æŒ
        ]
        return exchange in fpga_supported
    
    def _calculate_slippage_factor(self, order_request: OrderRequest, exchange: ExchangeType) -> float:
        """è®¡ç®—æ»‘ç‚¹å› å­"""
        # åŸºäºè®¢å•å¤§å°å’Œå¸‚åœºæ·±åº¦çš„æ»‘ç‚¹ä¼°è®¡
        base_slippage = 0.001  # 0.1%åŸºç¡€æ»‘ç‚¹
        
        # å¤§é¢è®¢å•å¢åŠ æ»‘ç‚¹
        size_factor = min(1.0, order_request.quantity / 1000.0)  # å‡è®¾1000ä¸ºåŸºå‡†
        base_slippage *= (1 + size_factor * 0.5)  # å¤§é¢è®¢å•å¢åŠ 50%æ»‘ç‚¹
        
        return base_slippage
    
    def _update_execution_metrics(self, order_response: OrderResponse, execution_time: float):
        """æ›´æ–°æ‰§è¡ŒæŒ‡æ ‡"""
        with self._metrics_lock:
            self._execution_metrics.total_orders += 1
            
            if order_response.status == OrderStatus.FILLED:
                self._execution_metrics.successful_orders += 1
            else:
                self._execution_metrics.failed_orders += 1
            
            # æ›´æ–°å¹³å‡æ‰§è¡Œæ—¶é—´
            current_avg = self._execution_metrics.average_execution_time
            total_orders = self._execution_metrics.total_orders
            self._execution_metrics.average_execution_time = (
                (current_avg * (total_orders - 1) + execution_time) / total_orders
            )
            
            # æ›´æ–°æˆåŠŸç‡
            self._execution_metrics.success_rate = (
                self._execution_metrics.successful_orders / self._execution_metrics.total_orders
            )
            
            # æ›´æ–°å³°å€¼å»¶è¿Ÿ
            if execution_time > self._execution_metrics.peak_latency:
                self._execution_metrics.peak_latency = execution_time
    
    # ğŸš€ ç³»ç»Ÿåˆå§‹åŒ–æ–¹æ³•
    
    def _initialize_execution_engine(self):
        """åˆå§‹åŒ–æ‰§è¡Œå¼•æ“"""
        try:
            self.logger.info("åˆå§‹åŒ–è®¢å•æ‰§è¡Œå¼•æ“...")
            
            # åˆå§‹åŒ–è·¯ç”±ç­–ç•¥
            self._initialize_routing_strategies()
            
            # åˆå§‹åŒ–æˆæœ¬ä¼˜åŒ–å™¨
            self._initialize_cost_optimizers()
            
            # åˆå§‹åŒ–äº¤æ˜“æ‰€å¥åº·ç›‘æ§
            self._initialize_exchange_health_monitor()
            
            # åŠ è½½é…ç½®
            self.load_config()
            
            self.logger.info("è®¢å•æ‰§è¡Œå¼•æ“åˆå§‹åŒ–å®Œæˆ")
            
        except Exception as e:
            self.logger.error(f"æ‰§è¡Œå¼•æ“åˆå§‹åŒ–å¤±è´¥: {e}")
    
    def _initialize_routing_strategies(self):
        """åˆå§‹åŒ–è·¯ç”±ç­–ç•¥"""
        self._routing_strategies = {
            "latency_priority": self._latency_priority_routing,
            "cost_priority": self._cost_priority_routing,
            "balanced": self._balanced_routing
        }
    
    def _initialize_cost_optimizers(self):
        """åˆå§‹åŒ–æˆæœ¬ä¼˜åŒ–å™¨"""
        self._cost_optimizers = {
            "slippage_reduction": self._optimize_slippage,
            "fee_minimization": self._optimize_fees,
            "execution_improvement": self._improve_execution
        }
    
    def _initialize_exchange_health_monitor(self):
        """åˆå§‹åŒ–äº¤æ˜“æ‰€å¥åº·ç›‘æ§"""
        for exchange in ExchangeType:
            self._exchange_health[exchange] = {
                "health_score": 1.0,
                "last_check": datetime.now(),
                "error_count": 0,
                "success_count": 0
            }
            self._latency_monitor[exchange] = []
    
    # ğŸš€ è·¯ç”±ç­–ç•¥å®ç°
    
    def _latency_priority_routing(self, order_request: OrderRequest) -> ExchangeType:
        """å»¶è¿Ÿä¼˜å…ˆè·¯ç”±"""
        lowest_latency = float('inf')
        best_exchange = self.default_exchange
        
        for exchange in self.enabled_exchanges:
            latency = self._get_average_latency(exchange)
            if latency < lowest_latency:
                lowest_latency = latency
                best_exchange = exchange
        
        return best_exchange
    
    def _cost_priority_routing(self, order_request: OrderRequest) -> ExchangeType:
        """æˆæœ¬ä¼˜å…ˆè·¯ç”±"""
        lowest_cost = float('inf')
        best_exchange = self.default_exchange
        
        for exchange in self.enabled_exchanges:
            cost = self._estimate_transaction_cost(order_request, exchange)
            if cost < lowest_cost:
                lowest_cost = cost
                best_exchange = exchange
        
        return best_exchange
    
    def _balanced_routing(self, order_request: OrderRequest) -> ExchangeType:
        """å¹³è¡¡è·¯ç”±ç­–ç•¥"""
        best_score = -1
        best_exchange = self.default_exchange
        
        for exchange in self.enabled_exchanges:
            latency_score = self._get_latency_score(exchange)
            cost_score = self._get_cost_score(exchange, order_request)
            health_score = self._get_health_score(exchange)
            
            # åŠ æƒå¾—åˆ†
            total_score = (latency_score * 0.4 + cost_score * 0.4 + health_score * 0.2)
            
            if total_score > best_score:
                best_score = total_score
                best_exchange = exchange
        
        return best_exchange
    
    def _get_average_latency(self, exchange: ExchangeType) -> float:
        """è·å–å¹³å‡å»¶è¿Ÿ"""
        latencies = self._latency_monitor.get(exchange, [])
        return sum(latencies) / len(latencies) if latencies else 100.0  # é»˜è®¤100ms
    
    def _estimate_transaction_cost(self, order_request: OrderRequest, exchange: ExchangeType) -> float:
        """ä¼°ç®—äº¤æ˜“æˆæœ¬"""
        # ç®€åŒ–å®ç°
        fee_rates = {
            ExchangeType.BINANCE: 0.001,
            ExchangeType.BYBIT: 0.00075,
            ExchangeType.OKX: 0.0008,
            ExchangeType.BINGX: 0.00085,  # æ–°å¢
            ExchangeType.BITGET: 0.00082, # æ–°å¢
            ExchangeType.MEXC: 0.00088,   # æ–°å¢
        }
        base_fee = fee_rates.get(exchange, 0.001)
        
        order_value = order_request.quantity * (order_request.price or 1.0)
        return order_value * base_fee
    
    # ğŸš€ æˆæœ¬ä¼˜åŒ–å™¨å®ç°
    
    def _optimize_slippage(self, order_request: OrderRequest, exchange: ExchangeType) -> OrderRequest:
        """ä¼˜åŒ–æ»‘ç‚¹"""
        # å®ç°æ»‘ç‚¹ä¼˜åŒ–é€»è¾‘
        return order_request
    
    def _optimize_fees(self, order_request: OrderRequest, exchange: ExchangeType) -> OrderRequest:
        """ä¼˜åŒ–æ‰‹ç»­è´¹"""
        # å®ç°æ‰‹ç»­è´¹ä¼˜åŒ–é€»è¾‘
        return order_request
    
    def _improve_execution(self, order_request: OrderRequest, exchange: ExchangeType) -> OrderRequest:
        """æ”¹è¿›æ‰§è¡Œ"""
        # æ”¹è¿›æ‰§è¡Œé€»è¾‘
        return order_request
    
    # ğŸš€ æ€§èƒ½ç›‘æ§å’ŒæŠ¥å‘Š
    
    def get_performance_metrics(self) -> PerformanceMetrics:
        """è·å–æ€§èƒ½æŒ‡æ ‡"""
        # æ›´æ–°ç¼“å­˜å‘½ä¸­ç‡
        total_operations = self._performance_metrics.call_count
        if total_operations > 0:
            self._performance_metrics.cache_hit_rate = self._performance_metrics.cache_hit_rate / total_operations
        
        return self._performance_metrics
    
    def get_execution_metrics(self) -> ExecutionMetrics:
        """è·å–æ‰§è¡ŒæŒ‡æ ‡"""
        return self._execution_metrics
    
    def get_order_history(self, limit: int = 100) -> List[Tuple[OrderRequest, OrderResponse]]:
        """è·å–è®¢å•å†å²"""
        with self._order_lock:
            return self._order_history[-limit:]
    
    def reset_metrics(self):
        """é‡ç½®æŒ‡æ ‡"""
        with self._metrics_lock:
            self._execution_metrics = ExecutionMetrics()
            self._performance_metrics = PerformanceMetrics(
                execution_time=0.0,
                memory_usage=0,
                cpu_usage=0.0,
                call_count=0,
                error_count=0,
                cache_hit_rate=0.0
            )
    
    def get_detailed_status(self) -> Dict[str, Any]:
        """è·å–è¯¦ç»†çŠ¶æ€"""
        return {
            "execution_mode": self.execution_mode.value,
            "enabled_exchanges": [e.value for e in self.enabled_exchanges],
            "fpga_enabled": self._fpga_enabled,
            "total_orders": self._execution_metrics.total_orders,
            "success_rate": self._execution_metrics.success_rate,
            "average_latency": self._execution_metrics.average_execution_time,
            "performance_metrics": self.get_performance_metrics().to_dict(),
            "exchange_health": {
                exchange.value: health_data 
                for exchange, health_data in self._exchange_health.items()
            }
        }

# å…¨å±€è®¢å•æ‰§è¡Œå™¨å®ä¾‹
_global_order_executor: Optional[UnifiedOrderExecutor] = None

def get_global_order_executor() -> UnifiedOrderExecutor:
    """è·å–å…¨å±€è®¢å•æ‰§è¡Œå™¨"""
    global _global_order_executor
    
    if _global_order_executor is None:
        _global_order_executor = UnifiedOrderExecutor()
        _global_order_executor.load_config()
    
    return _global_order_executor

# è‡ªåŠ¨æ³¨å†Œæ¥å£
from interfaces import InterfaceRegistry
InterfaceRegistry.register_interface(UnifiedOrderExecutor)

__all__ = [
    'UnifiedOrderExecutor',
    'OrderType',
    'OrderStatus', 
    'ExecutionMode',
    'ExchangeType',
    'OrderRequest',
    'OrderResponse',
    'ExecutionMetrics',
    'get_global_order_executor'
]